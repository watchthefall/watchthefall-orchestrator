<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WatchTheFall Portal</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#00ff00">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WTF Portal">
    
    <!-- App Icons -->
    <link rel="manifest" href="/portal/static/manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23000' width='100' height='100'/%3E%3Ctext y='70' font-size='70' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect fill='%23000' width='180' height='180' rx='40'/%3E%3Ctext x='90' y='130' font-size='100' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold' text-anchor='middle'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: #111;
            padding: 20px;
            border-bottom: 2px solid #00ff00;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #00ff00;
            font-size: 24px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .section {
            background: #1a1a1a;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        
        .section h2 {
            color: #00ff00;
            font-size: 18px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .upload-zone {
            border: 2px dashed #444;
            padding: 40px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-zone:hover {
            border-color: #00ff00;
            background: #1f1f1f;
        }
        
        .upload-zone.active {
            border-color: #00ff00;
            background: #1f3f1f;
        }
        
        input[type="file"] {
            display: none;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 12px;
            background: #222;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc00;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .status.queued { background: #333; color: #aaa; }
        .status.processing { background: #1a3a4a; color: #5bc0de; }
        .status.completed { background: #1a3a1a; color: #00ff00; }
        .status.failed { background: #3a1a1a; color: #ff5555; }
        
        .job-item {
            background: #222;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #444;
        }
        
        .job-item.completed { border-left-color: #00ff00; }
        .job-item.processing { border-left-color: #5bc0de; }
        .job-item.failed { border-left-color: #ff5555; }
        
        .job-meta {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .log-entry {
            padding: 8px 12px;
            background: #1a1a1a;
            border-left: 2px solid #444;
            margin-bottom: 5px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }
        
        .log-entry.error { border-left-color: #ff5555; color: #ffaaaa; }
        .log-entry.info { border-left-color: #5bc0de; }
        
        .download-link {
            color: #00ff00;
            text-decoration: none;
            font-weight: 600;
        }
        
        .download-link:hover {
            text-decoration: underline;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .section {
                padding: 15px;
            }
            
            h1 {
                font-size: 20px;
            }
        }
        
        /* Brand watermark styles */
        .brand-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }
        .brand-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #222;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #333;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }
        .brand-checkbox:hover {
            background: #2a2a2a;
            border-color: #00ff00;
        }
        .brand-checkbox input[type="checkbox"] {
            cursor: pointer;
        }
        .brand-checkbox input[type="checkbox"]:checked + span {
            color: #00ff00;
            font-weight: 600;
        }
        #watermarkStatus {
            margin-top: 15px;
        }
        .watermark-result {
            background: #222;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #00ff00;
        }
        
        /* Brand selector modal */
        .brand-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            overflow-y: auto;
        }
        .brand-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .brand-modal-content {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .brand-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .brand-modal-close {
            background: #444;
            color: #fff;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }
        .brand-modal-close:hover {
            background: #ff5555;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>‚ö° WatchTheFall Portal</h1>
            <div class="subtitle">Video Processing & Automation Control Panel</div>
        </div>
    </header>
    
    <div class="container">
        <!-- Multi-Link Downloader Section -->
        <div class="section">
            <h2>üîó Bulk Download & Upload</h2>
            <p style="color: #888; font-size: 14px; margin-bottom: 15px;">Paste up to 5 TikTok, Instagram, or X links (one per line) OR upload from your device</p>
            
            <textarea id="linksInput" placeholder="https://tiktok.com/@user/video/123...&#10;https://instagram.com/reel/abc...&#10;https://x.com/user/status/456..." 
                style="width:100%; min-height:120px; background:#111; border:1px solid #333; color:#ddd; padding:12px; border-radius:8px; font-size:14px; font-family:monospace; resize:vertical;"></textarea>
            
            <div style="display:flex; gap:10px; margin-top:12px;">
                <button id="fetchLinksBtn" style="flex:1; background:#00aa00;">üì• Download All Links</button>
                <button id="pasteClipboardBtn" style="flex:1; background:#0066ff;">üìã Paste from Clipboard</button>
                <button id="uploadFromDeviceBtn" style="flex:1; background:#ff6600;">üì± Upload from Device</button>
                <button id="resetLinksBtn" style="flex:1; background:#444;">‚ôª Reset</button>
            </div>
            <label style="display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px; color:#aaa;">
                <input type="checkbox" id="autoDownloadToggle"> Auto-download when ready
            </label>
            
            <!-- Hidden file input for device upload -->
            <input type="file" id="deviceVideoInput" accept="video/mp4,video/quicktime,video/webm" style="display:none;">
            
            <div id="fetchStatus" style="margin-top:15px;"></div>
        </div>
        
        <!-- Brand Watermark Section -->
        <div class="section">
            <h2>üé® Brand Watermark (Client-Side)</h2>
            <p style="color: #888; font-size: 14px; margin-bottom: 15px;">Select video from downloads or upload new ‚Ä¢ Choose brands ‚Ä¢ Get watermarked 9:16 versions instantly</p>
            
            <input type="file" id="watermarkVideoInput" accept="video/mp4,video/quicktime" style="display:none;">
            <button id="selectVideoBtn" style="width:100%; background:#0066ff; margin-bottom:15px;">üìÇ Select Video File</button>
            <div id="selectedVideoName" style="color:#aaa; font-size:13px; margin-bottom:15px;"></div>
            
            <label style="display:block; margin-bottom:8px; color:#aaa; font-size:14px; font-weight:600;">Select Brands (up to 10):</label>
            <div class="brand-grid" id="brandGrid">
                <!-- Brands loaded dynamically -->
            </div>
            
            <button id="applyWatermarksBtn" style="width:100%; margin-top:20px; background:#00aa00;" disabled>‚ö° Generate Watermarked Videos</button>
            
            <div id="watermarkStatus"></div>
        </div>
    </div>
    
    <!-- Brand Selector Modal -->
    <div id="brandModal" class="brand-modal">
        <div class="brand-modal-content">
            <div class="brand-modal-header">
                <h3 style="color:#00ff00; margin:0;">üé® Select Brands for Watermarking</h3>
                <div style="display:flex; gap:8px;">
                    <button class="brand-modal-minimize" onclick="minimizeBrandModal()" title="Minimize" style="background:#555; color:#fff; border:none; width:32px; height:32px; border-radius:4px; font-size:20px; cursor:pointer; display:flex; align-items:center; justify-content:center;">‚Äì</button>
                    <button class="brand-modal-close" onclick="closeBrandModal()">√ó</button>
                </div>
            </div>
            <div id="modalVideoName" style="color:#aaa; font-size:13px; margin-bottom:15px;"></div>
            
            <!-- Video Preview -->
            <div style="position:relative; margin-bottom:12px;">
                <video id="modalPreview"
                       style="width:100%; max-height:50vh; background:#000; border:1px solid #333; border-radius:8px; display:block;"
                       controls
                       muted
                       playsinline
                       onclick="this.paused ? this.play() : this.pause();"></video>
                <!-- Filename overlay (top-right) -->
                <div id="modalPreviewFilename" style="position:absolute; top:8px; right:8px; background:rgba(0,0,0,0.7); color:#0f0; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none; display:none;"></div>
                <!-- Play/pause hint (bottom-left) -->
                <div id="modalPreviewHint" style="position:absolute; bottom:8px; left:8px; background:rgba(0,0,0,0.7); color:#aaa; padding:4px 8px; border-radius:4px; font-size:11px; pointer-events:none; display:none;">‚ñ∂Ô∏è Tap to play/pause</div>
            </div>
            
            <p style="color:#888; font-size:14px; margin-bottom:15px;">Choose up to 10 brands to watermark this video. Each will be downloaded separately.</p>
            <p style="color:#0f0; font-size:13px; margin-bottom:15px; font-weight:600;">‚úÖ Smart Processing: Server handles one conversion at a time to ensure stability</p>
            
            <!-- Auto Download Toggle -->
            <div style="margin-bottom:15px; padding:10px; background:rgba(0,255,0,0.05); border:1px solid #333; border-radius:6px;">
                <label style="color:#aaa; font-size:13px; display:flex; align-items:center; cursor:pointer;">
                    <input type="checkbox" id="autoDownloadToggleModal" style="margin-right:8px;">
                    <span>üì• Auto-download videos when ready (may be blocked by browser)</span>
                </label>
                <div style="color:#666; font-size:11px; margin-top:4px;">üí° Tip: Manual download buttons shown for all videos</div>
            </div>
            
            <!-- Quality Preset Selector -->
            <div style="margin-bottom:15px; padding:10px; background:rgba(0,255,0,0.05); border:1px solid #333; border-radius:6px;">
                <label style="color:#aaa; font-size:13px; display:block; margin-bottom:6px;">‚ö° Quality Preset:</label>
                <select id="qualitySelect" style="width:100%; padding:6px; background:#1a1a1a; color:#0f0; border:1px solid #333; border-radius:4px;">
                    <option value="fast" selected>Fast (720p, 24fps, ~3Mbps) - Recommended for mobile</option>
                    <option value="balanced">Balanced (1080p, 27fps, ~4Mbps)</option>
                    <option value="high">High (1080p, 30fps, ~5Mbps)</option>
                    <option value="auto">Auto (Network & Device)</option>
                </select>
                <div id="qualityInfo" style="color:#666; font-size:11px; margin-top:4px;">üìä Fast preset selected (smoother playback)</div>
            </div>
            
            <div class="brand-grid" id="modalBrandGrid">
                <p style="color:#666;">Loading brands...</p>
            </div>
            <div style="margin-top:20px; display:flex; gap:10px;">
                <button id="modalGenerateBtn" style="flex:1; background:#00aa00;" disabled>‚ö° Generate Watermarked Videos</button>
                <button onclick="closeBrandModal()" style="flex:1; background:#444;">‚ùå Cancel</button>
            </div>
            <div id="modalStatus" style="margin-top:15px;"></div>
        </div>
    </div>
    
    <!-- Minimized Modal Bar Container (bottom of screen) -->
    <div id="minimizedModalsContainer" style="position:fixed; bottom:0; left:0; right:0; z-index:9999; pointer-events:none; padding:8px; display:flex; flex-direction:column; gap:8px;"></div>
    
    <script>
        let statusPollInterval = null;
        
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/portal/static/sw.js').catch(() => {});
        }
        
        // Auto-download toggle
        let autoDownloadEnabled = false;
        document.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('autoDownloadToggle');
            if (toggle) {
                toggle.addEventListener('change', (e) => {
                    autoDownloadEnabled = !!e.target.checked;
                });
            }
        });
        
        // Paste-All button
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.id === 'pasteClipboardBtn') {
                if (!navigator.clipboard) return;
                try {
                    const text = await navigator.clipboard.readText();
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) {
                        alert('No URLs found in clipboard');
                        return;
                    }
                    document.getElementById('linksInput').value = urls.join('\n');
                    document.getElementById('fetchStatus').innerHTML = '<div class="status queued">üìã Pasted URLs from clipboard.</div>';
                } catch (err) {
                    alert('Clipboard read failed');
                }
            }
            
            // Upload from device button
            if (e.target && e.target.id === 'uploadFromDeviceBtn') {
                document.getElementById('deviceVideoInput').click();
            }
        });
        
        // Handle device video upload
        document.getElementById('deviceVideoInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const statusDiv = document.getElementById('fetchStatus');
            statusDiv.innerHTML = `<div class="status processing">‚è≥ Uploading ${file.name}...</div>`;
            
            // Create a blob URL and immediately open the brand modal
            const blob = file;
            const url = URL.createObjectURL(blob);
            const filename = file.name;
            
            // Store for watermarking
            statusDiv.innerHTML = `<div class="status completed">‚úì Uploaded: ${filename} (${(file.size/(1024*1024)).toFixed(2)}MB)<br><a href="#" onclick="openBrandModalForUrl('${url}', '${filename}'); return false;" style="color:#0f0;">üé® Click to add watermarks</a></div>`;
            
            // Auto-open brand modal
            setTimeout(() => {
                openBrandModalForUrl(url, filename);
            }, 500);
            
            // Clear input
            e.target.value = '';
        });
        
        // Helpers
        function extractURLs(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return (text.match(urlRegex) || []).map(u => u.trim());
        }
        
        async function shareVideo(downloadUrl, filename) {
            try {
                if (!navigator.share) {
                    alert('Sharing not supported on this browser');
                    return;
                }
                const res = await fetch(downloadUrl);
                const blob = await res.blob();
                const file = new File([blob], filename || 'video.mp4', { type: 'video/mp4' });
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({ files: [file], title: filename || 'Video' });
                } else {
                    // Fallback: share URL
                    await navigator.share({ title: filename || 'Video', url: downloadUrl });
                }
            } catch (e) {
                alert('Share failed: ' + e.message);
            }
        }
        
        // Download video with fetch-to-blob for reliability (cross-browser compatible)
        async function downloadVideo(url, filename, buttonIndex) {
            const button = document.getElementById(`dlBtn${buttonIndex}`);
            const originalText = button ? button.innerHTML : '';
            
            try {
                if (button) {
                    button.disabled = true;
                    button.innerHTML = '‚è≥ Downloading...';
                    button.style.background = '#666';
                }
                
                console.log('[DOWNLOAD] Fetching blob for:', filename);
                
                // Fetch the video as a blob
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const blob = await response.blob();
                console.log('[DOWNLOAD] Blob fetched:', blob.size, 'bytes');
                
                // Create a temporary blob URL
                const blobUrl = URL.createObjectURL(blob);
                
                // Create download link and trigger it
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(blobUrl);
                }, 100);
                
                if (button) {
                    button.innerHTML = '‚úì Downloaded!';
                    button.style.background = '#0a0';
                    setTimeout(() => {
                        button.disabled = false;
                        button.innerHTML = originalText;
                        button.style.background = '#00aa00';
                    }, 2000);
                }
                
                console.log('[DOWNLOAD] Download triggered for:', filename);
                
            } catch (err) {
                console.error('[DOWNLOAD ERROR]:', err);
                
                if (button) {
                    button.innerHTML = '‚ùå Failed - Try Again';
                    button.style.background = '#a00';
                    setTimeout(() => {
                        button.disabled = false;
                        button.innerHTML = originalText;
                        button.style.background = '#00aa00';
                    }, 3000);
                }
                
                // Fallback: try direct link open
                console.log('[DOWNLOAD] Fetch failed, trying direct link...');
                window.open(url, '_blank');
            }
        }
        
        // Delegate click for share buttons and copy-all-links
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.classList.contains('share-btn')) {
                const url = e.target.getAttribute('data-url');
                const name = e.target.getAttribute('data-filename') || 'video.mp4';
                await shareVideo(url, name);
            }
            if (e.target && e.target.id === 'copyAllLinksBtn') {
                const links = [];
                document.querySelectorAll('.download-link').forEach(a => {
                    if (a.href) links.push(a.href);
                });
                if (links.length) {
                    try {
                        await navigator.clipboard.writeText(links.join('\n'));
                        e.target.textContent = '‚úì Copied!';
                        setTimeout(() => { e.target.textContent = 'üìã Copy All Download Links'; }, 2000);
                    } catch (err) {
                        alert('Copy failed: ' + err.message);
                    }
                } else {
                    alert('No download links found');
                }
            }
        });
        
        function saveHistoryEntry(entry) {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            hist.unshift({ ...entry, ts: Date.now() });
            hist = hist.slice(0,20);
            localStorage.setItem(key, JSON.stringify(hist));
            renderHistory();
        }
        function renderHistory() {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            const container = document.getElementById('historyList');
            if (!container) return;
            if (!hist.length) {
                container.innerHTML = '<p style="color:#666;">No history yet</p>';
                return;
            }
            container.innerHTML = hist.map(h => `
                <div class="job-item">
                    <strong>${h.name || h.filename || 'Video'}</strong>
                    <div class="job-meta">${new Date(h.ts).toLocaleString()}${h.size_mb ? ` ‚Ä¢ ${h.size_mb}MB` : ''}
                    ${h.url ? `<br><a href="${h.url}" class="download-link" download="${h.name || 'video.mp4'}">üì• Download</a> <button class="share-btn" data-url="${h.url}" data-filename="${h.name || 'video.mp4'}" style="margin-left:8px;">ü§ù Share</button>` : ''}</div>
                </div>
            `).join('');
        }
        
        // ========== PHASE B: CLIENT-SIDE WATERMARK SYSTEM ==========
        let selectedVideoFile = null;
        let brandWatermarks = {};
        let brandsLoaded = false;
        let pendingVideoBlob = null;
        let pendingVideoFilename = null;
        let currentModalProgress = { current: 0, total: 0, brandName: '', percent: 0 };
        let isModalMinimized = false;
        
        // ========== TSS / BROWSER EXTENSION DETECTION ==========
        // Detect Trend Micro, HP Wolf, Microsoft Defender extensions that block uploads
        function detectSecurityExtensionInterference() {
            const warnings = [];
            
            // Check for TSS injection
            if (window.document.querySelector('script[src*="injection-tss"]') || 
                window.document.querySelector('script[src*="tss-mv3"]')) {
                warnings.push('‚ö†Ô∏è Trend Micro / HP Wolf Security detected - may block uploads');
            }
            
            // Check for runtime errors (TSS creates these)
            const originalError = console.error;
            let runtimeErrorDetected = false;
            console.error = function(...args) {
                if (args.some(a => String(a).includes('runtime.lastError') || String(a).includes('Receiving end does not exist'))) {
                    runtimeErrorDetected = true;
                }
                originalError.apply(console, args);
            };
            
            // Check for excessive URL.createObjectURL calls being intercepted
            if (performance && performance.getEntriesByType) {
                const resources = performance.getEntriesByType('resource');
                const tssResources = resources.filter(r => r.name.includes('injection-tss') || r.name.includes('tss-mv3'));
                if (tssResources.length > 0) {
                    warnings.push('‚ö†Ô∏è Security extension detected interfering with MediaRecorder');
                }
            }
            
            return warnings;
        }
        
        // Show warning banner if interference detected
        function showExtensionWarning() {
            const warnings = detectSecurityExtensionInterference();
            if (warnings.length === 0) return;
            
            const banner = document.createElement('div');
            banner.id = 'extensionWarning';
            banner.style.cssText = 'position:fixed; top:60px; left:50%; transform:translateX(-50%); z-index:10000; background:#ff6600; color:#000; padding:16px 24px; border-radius:8px; box-shadow:0 4px 12px rgba(255,102,0,0.5); max-width:90%; font-weight:600; text-align:center; animation:slideDown 0.3s ease-out;';
            banner.innerHTML = `
                <div style="margin-bottom:8px;">${warnings.join('<br>')}</div>
                <div style="font-size:12px; font-weight:normal; color:#1a1a1a;">‚úÖ Fix: Disable browser security extensions OR use Incognito mode</div>
                <button onclick="this.parentElement.remove()" style="margin-top:8px; background:#000; color:#0f0; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-weight:600;">Got it</button>
            `;
            document.body.appendChild(banner);
            
            console.warn('[TSS DETECTION]', warnings.join(', '));
        }
        
        // Run detection after page load
        setTimeout(showExtensionWarning, 2000);
        
        // Quality preset detection
        function getQualityPreset() {
            const selected = document.getElementById('qualitySelect')?.value;
            
            // Manual selection overrides auto
            if (selected && selected !== 'auto') {
                const presets = {
                    fast: { name: 'Fast', width: 720, height: 1280, fps: 24, bitrate: 3000000 },
                    balanced: { name: 'Balanced', width: 1080, height: 1920, fps: 27, bitrate: 4000000 },
                    high: { name: 'High', width: 1080, height: 1920, fps: 30, bitrate: 5000000 }
                };
                return presets[selected];
            }
            
            // Auto detection
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            const memory = navigator.deviceMemory || 4;
            const cores = navigator.hardwareConcurrency || 4;
            
            let preset = 'balanced';
            let reason = 'default';
            
            if (conn) {
                const effectiveType = conn.effectiveType;
                const downlink = conn.downlink || 5;
                const rtt = conn.rtt || 100;
                const saveData = conn.saveData || false;
                
                if (saveData || effectiveType === 'slow-2g' || effectiveType === '2g' || downlink < 2 || rtt > 300) {
                    preset = 'fast';
                    reason = `${effectiveType || 'slow network'}`;
                } else if (effectiveType === '3g' || downlink < 5 || rtt > 200) {
                    preset = 'balanced';
                    reason = effectiveType || '3g';
                } else if (effectiveType === '4g' && downlink >= 5 && rtt <= 200) {
                    preset = 'high';
                    reason = '4g, good signal';
                }
            }
            
            // Downgrade for low-end devices
            if (memory < 4 || cores < 4) {
                if (preset === 'high') preset = 'balanced';
                else if (preset === 'balanced') preset = 'fast';
                reason += `, low device memory/cores`;
            }
            
            const presets = {
                fast: { name: 'Fast', width: 720, height: 1280, fps: 24, bitrate: 3000000 },
                balanced: { name: 'Balanced', width: 1080, height: 1920, fps: 27, bitrate: 4000000 },
                high: { name: 'High', width: 1080, height: 1920, fps: 30, bitrate: 5000000 }
            };
            
            const result = presets[preset];
            result.reason = reason;
            return result;
        }
        
        // Codec detection - find best supported codec for device (fixes laptop compatibility)
        function getSupportedCodec() {
            // Test codecs in order of preference (best quality first)
            const codecs = [
                'video/webm;codecs=vp9,opus',     // VP9 - best quality
                'video/webm;codecs=vp8,opus',     // VP8 - wider support
                'video/webm;codecs=vp9',          // VP9 without audio codec
                'video/webm;codecs=vp8',          // VP8 without audio codec
                'video/webm'                       // Generic fallback
            ];
            
            for (const codec of codecs) {
                if (MediaRecorder.isTypeSupported(codec)) {
                    console.log(`[CODEC] Using: ${codec}`);
                    return codec;
                }
            }
            
            // Ultimate fallback - try any WebM
            console.warn('[CODEC] No preferred codec supported, using generic video/webm');
            return 'video/webm';
        }
        
        // Brand modal functions
        function closeBrandModal() {
            document.getElementById('brandModal').classList.remove('active');
            document.querySelectorAll('.modal-brand-check').forEach(cb => cb.checked = false);
            document.getElementById('modalStatus').innerHTML = '';
            
            // Clean up preview video
            const preview = document.getElementById('modalPreview');
            if (preview && preview.src) {
                URL.revokeObjectURL(preview.src);
                preview.src = '';
                preview.load();
            }
            
            // Remove minimized bar if exists
            const minimizedBar = document.getElementById('minimizedModalBar');
            if (minimizedBar) minimizedBar.remove();
            isModalMinimized = false;
            
            pendingVideoBlob = null;
            pendingVideoFilename = null;
        }
        
        function minimizeBrandModal() {
            const modal = document.getElementById('brandModal');
            const container = document.getElementById('minimizedModalsContainer');
            
            // Hide modal
            modal.classList.remove('active');
            isModalMinimized = true;
            
            // Create minimized bar if it doesn't exist
            let minimizedBar = document.getElementById('minimizedModalBar');
            if (!minimizedBar) {
                minimizedBar = document.createElement('div');
                minimizedBar.id = 'minimizedModalBar';
                minimizedBar.style.cssText = 'background:#1a1a1a; border:2px solid #0f0; border-radius:8px; padding:12px; cursor:pointer; pointer-events:auto; box-shadow:0 -2px 10px rgba(0,255,0,0.3);';
                minimizedBar.onclick = maximizeBrandModal;
                container.appendChild(minimizedBar);
            }
            
            updateMinimizedBar();
        }
        
        function maximizeBrandModal() {
            const modal = document.getElementById('brandModal');
            isModalMinimized = false;
            modal.classList.add('active');
        }
        
        function updateMinimizedBar() {
            const minimizedBar = document.getElementById('minimizedModalBar');
            if (!minimizedBar || !isModalMinimized) return;
            
            const { current, total, brandName, percent } = currentModalProgress;
            
            let statusText = `üé¨ ${pendingVideoFilename || 'Video'}`;
            if (total > 0) {
                statusText = `‚è≥ ${current}/${total}: ${brandName} - ${percent}%`;
            }
            
            minimizedBar.innerHTML = `
                <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                    <div style="flex:1; min-width:0;">
                        <div style="color:#0f0; font-weight:bold; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${statusText}</div>
                        ${total > 0 ? `
                            <div style="background:#333; border-radius:4px; overflow:hidden; height:6px; margin-top:4px;">
                                <div style="background:#0f0; height:100%; width:${percent}%; transition:width 0.3s;"></div>
                            </div>
                        ` : ''}
                    </div>
                    <div style="color:#888; font-size:11px;">üëÜ Tap to open</div>
                </div>
            `;
        }
        
        async function openBrandModalForUrl(videoUrl, filename) {
            try {
                console.log('[MODAL] Opening brand modal for:', filename);
                console.log('[MODAL] Brands loaded:', brandsLoaded);
                console.log('[MODAL] Brand count:', Object.keys(brandWatermarks).length);
                
                // Wait for brands to load first
                if (!brandsLoaded) {
                    alert('Loading brands... please wait a moment and try again.');
                    return;
                }
                
                // Detect quality preset and show info
                const preset = getQualityPreset();
                const qualityInfoDiv = document.getElementById('qualityInfo');
                const selectedValue = document.getElementById('qualitySelect')?.value;
                
                if (selectedValue === 'auto' && preset.reason) {
                    qualityInfoDiv.textContent = `üìä Auto: ${preset.name} (${preset.width}x${preset.height}, ${preset.fps}fps) - ${preset.reason}`;
                } else {
                    qualityInfoDiv.textContent = `üìä ${preset.name}: ${preset.width}x${preset.height}, ${preset.fps}fps, ~${(preset.bitrate/1000000).toFixed(1)}Mbps`;
                }
                
                // Fetch video as blob
                document.getElementById('modalVideoName').textContent = `üé¨ Loading: ${filename}...`;
                document.getElementById('brandModal').classList.add('active');
                
                // Show preview immediately with streaming URL
                const preview = document.getElementById('modalPreview');
                preview.src = videoUrl;
                preview.load();
                document.getElementById('modalPreviewFilename').textContent = filename;
                document.getElementById('modalPreviewFilename').style.display = 'block';
                document.getElementById('modalPreviewHint').style.display = 'block';
                
                // Hide hint when playing
                preview.onplay = () => document.getElementById('modalPreviewHint').style.display = 'none';
                preview.onpause = () => document.getElementById('modalPreviewHint').style.display = 'block';
                
                // Debug: Check if grid has content
                const gridHTML = document.getElementById('modalBrandGrid').innerHTML;
                console.log('[MODAL] Grid HTML length:', gridHTML.length);
                console.log('[MODAL] Grid first 200 chars:', gridHTML.substring(0, 200));
                
                const response = await fetch(videoUrl);
                if (!response.ok) throw new Error('Failed to load video');
                
                pendingVideoBlob = await response.blob();
                pendingVideoFilename = filename;
                
                // Update preview with blob URL for better playback
                const blobUrl = URL.createObjectURL(pendingVideoBlob);
                preview.src = blobUrl;
                preview.load();
                
                const durationStr = preview.duration ? ` ‚Ä¢ ${Math.floor(preview.duration)}s` : '';
                document.getElementById('modalVideoName').textContent = `üé¨ ${filename} (${(pendingVideoBlob.size/(1024*1024)).toFixed(2)}MB${durationStr})`;
            } catch (err) {
                console.error('[MODAL] Error:', err);
                alert('Failed to load video: ' + err.message);
                closeBrandModal();
            }
        }
        
        // Intercept download link clicks
        document.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('download-link')) {
                e.preventDefault();
                const url = e.target.getAttribute('href');
                const filename = e.target.getAttribute('download') || 'video.mp4';
                openBrandModalForUrl(url, filename);
            }
        });
        
        // Load brand watermarks config
        fetch('/portal/static/watermarks/brands.json')
            .then(r => r.json())
            .then(brands => {
                brandWatermarks = brands;
                
                // Populate main brand grid
                const grid = document.getElementById('brandGrid');
                grid.innerHTML = Object.keys(brands).map((brandName, idx) => `
                    <label class="brand-checkbox">
                        <input type="checkbox" class="brand-check" value="${brandName}" data-file="${brands[brandName]}">
                        <span>${brandName}</span>
                    </label>
                `).join('');
                
                // Populate modal brand grid
                const modalGrid = document.getElementById('modalBrandGrid');
                modalGrid.innerHTML = Object.keys(brands).map((brandName, idx) => `
                    <label class="brand-checkbox">
                        <input type="checkbox" class="modal-brand-check" value="${brandName}" data-file="${brands[brandName]}">
                        <span>${brandName}</span>
                    </label>
                `).join('');
                
                console.log(`[BRANDS] Loaded ${Object.keys(brands).length} brands into modal grid`);
                brandsLoaded = true;
                
                // Enable/disable button based on selection (main section)
                document.querySelectorAll('.brand-check').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const selected = document.querySelectorAll('.brand-check:checked').length;
                        const applyBtn = document.getElementById('applyWatermarksBtn');
                        applyBtn.disabled = !(selectedVideoFile && selected > 0 && selected <= 10);
                        if (selected > 10) {
                            alert('Maximum 10 brands at a time');
                            cb.checked = false;
                        }
                    });
                });
                
                // Enable/disable button based on selection (modal)
                document.querySelectorAll('.modal-brand-check').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const selected = document.querySelectorAll('.modal-brand-check:checked').length;
                        const generateBtn = document.getElementById('modalGenerateBtn');
                        generateBtn.disabled = !(selected > 0 && selected <= 10);
                        if (selected > 10) {
                            alert('Maximum 10 brands at a time');
                            cb.checked = false;
                        }
                    });
                });
            })
            .catch(err => {
                console.error('[BRANDS] Failed to load brands.json:', err);
                alert('Failed to load brand list. Please refresh the page.');
            });
        
        // Modal Generate button handler - sequential processing with retry logic
        document.getElementById('modalGenerateBtn').addEventListener('click', async () => {
            const selected = Array.from(document.querySelectorAll('.modal-brand-check:checked'));
            if (!pendingVideoBlob || !selected.length) return;
            
            const statusDiv = document.getElementById('modalStatus');
            const preset = getQualityPreset();
            const autoDownload = document.getElementById('autoDownloadToggleModal')?.checked || false;
            
            // Show initial status
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            statusDiv.innerHTML = `<div class="status processing">‚è≥ Initializing processing...<br><small style="color:#888;">‚ö° Quality: ${preset.name} (${preset.width}x${preset.height}, ${preset.fps}fps) | ${selected.length} brands selected</small></div>`;
            document.getElementById('modalGenerateBtn').disabled = true;
            
            const results = [];
            const totalBrands = selected.length;
            
            // Helper: Upload and convert with async job polling (non-blocking)
            async function uploadAndConvert(watermarkedBlob, brandName, index, retryCount = 0) {
                const webmFilename = `${brandName}_${pendingVideoFilename.replace(/\.[^/.]+$/, '')}.webm`;
                const formData = new FormData();
                formData.append('video', watermarkedBlob, webmFilename);
                
                const xhr = new XMLHttpRequest();
                
                // Upload progress tracking
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        const uploadBar = document.getElementById(`uploadBar${index}`);
                        const uploadText = document.getElementById(`uploadText${index}`);
                        if (uploadBar) uploadBar.style.width = `${percent}%`;
                        if (uploadText) uploadText.textContent = `Stage 2/4: Uploading ${percent}%`;
                    }
                });
                
                return new Promise(async (resolve, reject) => {
                    xhr.open('POST', '/api/videos/convert-watermark');
                    
                    xhr.onload = async () => {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            
                            if (xhr.status >= 200 && xhr.status < 300) {
                                // Job queued - start polling for status
                                const jobId = response.job_id;
                                console.log(`[CONVERT] Job ${jobId.substr(0,8)} queued for ${brandName}`);
                                
                                statusDiv.innerHTML = `<div class="status processing">‚öôÔ∏è Converting ${index + 1}/${totalBrands}: <strong>${brandName}</strong>...<br><small style="color:#888;">Stage 3/4: FFmpeg processing (this may take a minute)...</small></div>`;
                                
                                // Poll job status until complete
                                const pollInterval = 2000; // 2 seconds
                                const maxPolls = 90; // 3 minutes max (90 * 2s = 180s)
                                let pollCount = 0;
                                
                                const pollStatus = async () => {
                                    try {
                                        const statusResp = await fetch(`/api/videos/convert-status/${jobId}`);
                                        const statusData = await statusResp.json();
                                        
                                        if (statusData.status === 'completed') {
                                            // Success!
                                            console.log(`[CONVERT] Job ${jobId.substr(0,8)} completed: ${statusData.filename}`);
                                            statusDiv.innerHTML = `<div class="status processing">‚úÖ Converted ${index + 1}/${totalBrands}: <strong>${brandName}</strong> to MP4<br><small style="color:#0f0;">Stage 4/4: Ready for download (${statusData.size_mb}MB)</small></div>`;
                                            resolve({
                                                success: true,
                                                brandName,
                                                url: statusData.download_url,
                                                filename: statusData.filename,
                                                size_mb: statusData.size_mb,
                                                conversion_time: statusData.conversion_time
                                            });
                                        } else if (statusData.status === 'failed') {
                                            // Failed
                                            console.error(`[CONVERT] Job ${jobId.substr(0,8)} failed:`, statusData.error);
                                            const errorMsg = statusData.stderr_preview || statusData.error || 'Unknown error';
                                            reject(new Error(`Conversion failed: ${errorMsg}`));
                                        } else if (statusData.status === 'processing' || statusData.status === 'queued') {
                                            // Still processing - poll again
                                            pollCount++;
                                            if (pollCount >= maxPolls) {
                                                reject(new Error('Conversion timeout (>3min)'));
                                            } else {
                                                const elapsed = Math.floor(pollCount * pollInterval / 1000);
                                                statusDiv.innerHTML = `<div class="status processing">‚öôÔ∏è Converting ${index + 1}/${totalBrands}: <strong>${brandName}</strong>...<br><small style="color:#888;">Stage 3/4: ${statusData.message || 'Processing'} (${elapsed}s elapsed)</small></div>`;
                                                setTimeout(pollStatus, pollInterval);
                                            }
                                        } else {
                                            reject(new Error(`Unknown status: ${statusData.status}`));
                                        }
                                    } catch (pollError) {
                                        reject(new Error(`Polling error: ${pollError.message}`));
                                    }
                                };
                                
                                // Start polling immediately
                                setTimeout(pollStatus, 1000); // Wait 1s before first poll
                                
                            } else {
                                reject(new Error(`HTTP ${xhr.status}: ${response.message || response.error || 'Unknown error'}`));
                            }
                        } catch (parseError) {
                            reject(new Error(`Failed to parse server response: ${parseError.message}`));
                        }
                    };
                    
                    xhr.onerror = () => {
                        // Upload failed - likely blocked by security extension
                        console.error('[UPLOAD BLOCKED] Network error during upload - security extension may be interfering');
                        
                        // Offer direct WebM download as fallback
                        const webmUrl = URL.createObjectURL(watermarkedBlob);
                        statusDiv.innerHTML = `
                            <div class="status" style="border-left-color:#ff6600;">
                                ‚ö†Ô∏è Upload blocked (security extension interference)<br>
                                <small style="color:#888; display:block; margin:8px 0;">Your browser extension blocked the upload. Download the watermarked WebM instead:</small>
                                <a href="${webmUrl}" download="${webmFilename}" style="display:inline-block; margin-top:8px; padding:10px 18px; background:#0f0; color:#000; border-radius:6px; font-weight:600; text-decoration:none; cursor:pointer;">
                                    üíæ Download ${brandName} WebM (works offline)
                                </a>
                                <div style="font-size:11px; color:#666; margin-top:8px;">Tip: Disable Trend Micro/HP Wolf extension or use Incognito mode</div>
                            </div>
                        `;
                        
                        reject(new Error('Network error during upload (security extension blocked)'));
                    };
                    xhr.send(formData);
                });
            }
            
            // Process brands in batches
            for (let i = 0; i < totalBrands; i++) {
                const brandName = selected[i].value;
                const watermarkFile = selected[i].getAttribute('data-file');
                
                currentModalProgress = { current: i + 1, total: totalBrands, brandName, percent: 0 };
                
                try {
                    // Stage 1: Watermark rendering
                    const progressHTML = `
                        <div class="status processing">
                            ‚è≥ Processing ${i + 1}/${totalBrands}: <strong>${brandName}</strong><br>
                            <div style="background:#333; border-radius:4px; overflow:hidden; height:10px; margin:8px 0;">
                                <div id="progressBar${i}" style="background:linear-gradient(90deg, #0f0, #0aa); height:100%; width:0%; transition:width 0.3s;"></div>
                            </div>
                            <small id="progressText${i}" style="color:#888; display:block; margin-top:4px;">Stage 1/4: Applying watermark...</small>
                        </div>
                    `;
                    statusDiv.innerHTML = progressHTML;
                    updateMinimizedBar();
                    
                    const videoFile = new File([pendingVideoBlob], pendingVideoFilename, { type: pendingVideoBlob.type });
                    const watermarkedBlob = await applyWatermarkToVideo(videoFile, watermarkFile, brandName, (progress) => {
                        const bar = document.getElementById(`progressBar${i}`);
                        const text = document.getElementById(`progressText${i}`);
                        if (bar) bar.style.width = `${progress}%`;
                        if (text) text.textContent = `Stage 1/4: Watermark ${progress}% complete`;
                        currentModalProgress.percent = progress;
                        updateMinimizedBar();
                    });
                    
                    // Stage 2: Upload
                    statusDiv.innerHTML = `<div class="status processing">üì§ Uploading ${i + 1}/${totalBrands}: <strong>${brandName}</strong>...<br><div style="background:#333; border-radius:4px; overflow:hidden; height:10px; margin:8px 0;"><div id="uploadBar${i}" style="background:linear-gradient(90deg, #0ff, #08f); height:100%; width:0%; transition:width 0.3s;"></div></div><small id="uploadText${i}" style="color:#888; display:block; margin-top:4px;">Stage 2/4: Preparing upload...</small></div>`;
                    updateMinimizedBar();
                    
                    // Stage 3 & 4: Convert (with retry and busy-wait)
                    const result = await uploadAndConvert(watermarkedBlob, brandName, i);
                    
                    results.push(result);
                    saveHistoryEntry({ type: 'watermark', name: result.filename, url: result.url, size_mb: result.size_mb });
                    
                } catch (err) {
                    console.error(`[WATERMARK ERROR] ${brandName}:`, err);
                    
                    const is429 = err.message.includes('busy') || err.message.includes('429');
                    const is50x = err.message.includes('500') || err.message.includes('502') || err.message.includes('Server error');
                    
                    let errorMsg = err.message || String(err);
                    if (is429) {
                        errorMsg = 'Server was too busy after multiple retries. Try again in a moment.';
                    } else if (is50x) {
                        errorMsg = 'Server overload or crash. Try shorter videos or wait for server to restart.';
                    }
                    
                    results.push({ 
                        brandName, 
                        error: errorMsg,
                        errorDetails: `üö´ ${err.name || 'Error'}: ${errorMsg}<br><small style="color:#888;">${is429 || is50x ? 'Skipped this brand - continuing with others' : err.stack ? err.stack.split('\n')[0] : ''}</small>`
                    });
                }
            }
            
            // Show final results
            const successCount = results.filter(r => r.success).length;
            const failedCount = results.filter(r => r.error).length;
            const items = results.map((r, idx) => {
                if (r.error) {
                    return `<div class="watermark-result" style="border-left-color:#ff5555; padding:15px;">‚úó <strong>${r.brandName}</strong><br>${r.errorDetails || r.error}</div>`;
                }
                return `<div class="watermark-result">‚úì <strong>${r.brandName}</strong> (${r.size_mb}MB, ${r.conversion_time}s)<br><button onclick="downloadVideo('${r.url}', '${r.filename}', ${idx})" id="dlBtn${idx}" style="display:inline-block; margin-top:8px; padding:10px 18px; background:#00aa00; color:#000; border:none; border-radius:6px; font-weight:600; cursor:pointer; font-size:14px;">üì• Download ${r.filename}</button></div>`;
            }).join('');
            
            const summaryColor = failedCount === 0 ? '#0f0' : (successCount > 0 ? '#ff6600' : '#ff5555');
            statusDiv.innerHTML = `<div class="status completed">‚úì Complete: ${successCount} successful, ${failedCount} failed<br><small style="color:${summaryColor}; margin-top:8px; display:block; font-weight:600;">üëá Click each button below to download:</small></div>${items}`;
            
            // Auto-download if enabled
            if (autoDownload && successCount > 0) {
                console.log('[AUTO-DOWNLOAD] Starting auto-download for', successCount, 'videos');
                for (let idx = 0; idx < results.length; idx++) {
                    if (results[idx].success) {
                        // Small delay between downloads to avoid browser blocking
                        await new Promise(r => setTimeout(r, 500));
                        downloadVideo(results[idx].url, results[idx].filename, idx);
                    }
                }
            }
            
            currentModalProgress = { current: 0, total: 0, brandName: '', percent: 0 };
            updateMinimizedBar();
            
            console.log(`[BATCH COMPLETE] ${successCount}/${totalBrands} brands successful`);
            
            renderHistory();
            document.getElementById('modalGenerateBtn').disabled = false;
        });
        
        // Select video file
        document.getElementById('selectVideoBtn').addEventListener('click', () => {
            document.getElementById('watermarkVideoInput').click();
        });
        
        document.getElementById('watermarkVideoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            selectedVideoFile = file;
            document.getElementById('selectedVideoName').textContent = `‚úì Selected: ${file.name} (${(file.size/(1024*1024)).toFixed(2)}MB)`;
            const selected = document.querySelectorAll('.brand-check:checked').length;
            document.getElementById('applyWatermarksBtn').disabled = !(selected > 0 && selected <= 10);
        });
        
        // Apply watermarks (Canvas-based with adaptive opacity 10-20%)
        document.getElementById('applyWatermarksBtn').addEventListener('click', async () => {
            const selected = Array.from(document.querySelectorAll('.brand-check:checked'));
            if (!selectedVideoFile || !selected.length) return;
            
            const statusDiv = document.getElementById('watermarkStatus');
            statusDiv.innerHTML = '<div class="status processing">‚è≥ Processing watermarks...</div>';
            document.getElementById('applyWatermarksBtn').disabled = true;
            
            const results = [];
            
            for (let i = 0; i < selected.length; i++) {
                const brandName = selected[i].value;
                const watermarkFile = selected[i].getAttribute('data-file');
                
                try {
                    statusDiv.innerHTML = `<div class="status processing">‚è≥ Processing ${i+1}/${selected.length}: ${brandName}...</div>`;
                    
                    const watermarkedBlob = await applyWatermarkToVideo(selectedVideoFile, watermarkFile, brandName);
                    const url = URL.createObjectURL(watermarkedBlob);
                    // Use .webm extension for proper file type recognition
                    const filename = `${brandName}_${selectedVideoFile.name.replace(/\.[^/.]+$/, '')}.webm`;
                    
                    results.push({ brandName, url, filename, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                    // Save to history
                    saveHistoryEntry({ type: 'watermark', name: filename, url, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                } catch (err) {
                    results.push({ brandName, error: err.message });
                }
            }
            
            // Show results
            const successCount = results.filter(r => !r.error).length;
            const items = results.map(r => {
                if (r.error) {
                    return `<div class="watermark-result" style="border-left-color:#ff5555;">‚úó ${r.brandName}: ${r.error}</div>`;
                }
                return `<div class="watermark-result">‚úì <strong>${r.brandName}</strong><br><a href="${r.url}" download="${r.filename}" class="download-link">üì• ${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
            }).join('');
            
            statusDiv.innerHTML = `<div class="status completed">‚úì Generated ${successCount}/${results.length} watermarked videos</div>${items}`;
            
            // Auto-download if enabled
            if (autoDownloadEnabled) {
                results.filter(r => !r.error).forEach(r => {
                    const a = document.createElement('a');
                    a.href = r.url;
                    a.download = r.filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                });
            }
            
            document.getElementById('applyWatermarksBtn').disabled = false;
        });
        
        // Canvas-based watermark application with adaptive opacity (10-20%)
        async function applyWatermarkToVideo(videoFile, watermarkFileName, brandName, onProgress = null) {
            return new Promise(async (resolve, reject) => {
                try {
                    // Get quality preset
                    const preset = getQualityPreset();
                    console.log(`[WATERMARK] Using preset: ${preset.name} (${preset.width}x${preset.height}, ${preset.fps}fps, ${(preset.bitrate/1000000).toFixed(1)}Mbps)`);
                    
                    // Mobile/browser detection and capability check
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    console.log(`[WATERMARK] Device: ${isMobile ? 'Mobile' : 'Desktop'}, Browser: ${navigator.userAgent.substring(0, 50)}...`);
                    
                    // Check MediaRecorder support
                    if (!window.MediaRecorder) {
                        throw new Error('‚ùå MediaRecorder not supported. Try Chrome/Firefox/Edge.');
                    }
                    
                    // Check Canvas.captureStream support
                    const testCanvas = document.createElement('canvas');
                    if (!testCanvas.captureStream && !testCanvas.mozCaptureStream) {
                        throw new Error('‚ùå Canvas.captureStream() not supported on this browser.');
                    }
                    console.log('[WATERMARK] ‚úì MediaRecorder and captureStream supported');
                    
                    if (onProgress) onProgress(5);
                    
                    // Load video
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(videoFile);
                    video.muted = true;
                    video.playsInline = true;
                    
                    await new Promise((res, rej) => {
                        video.onloadedmetadata = res;
                        video.onerror = rej;
                    });
                    
                    if (onProgress) onProgress(10);
                    
                    // Load watermark
                    const watermark = new Image();
                    watermark.src = `/portal/static/watermarks/${watermarkFileName}`;
                    await new Promise((res, rej) => {
                        watermark.onload = () => {
                            console.log(`[WATERMARK] Image loaded: ${watermarkFileName}, Size: ${watermark.width}x${watermark.height}`);
                            res();
                        };
                        watermark.onerror = (err) => {
                            console.error(`[WATERMARK] Failed to load image: ${watermarkFileName}`, err);
                            rej(new Error(`Failed to load watermark image: ${watermarkFileName}`));
                        };
                    });
                    
                    if (onProgress) onProgress(15);
                    
                    // Use preset dimensions
                    const targetWidth = preset.width;
                    const targetHeight = preset.height;
                    
                    // Canvas setup
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate video brightness for adaptive opacity
                    video.currentTime = video.duration / 2; // Sample middle frame
                    await new Promise(res => { video.onseeked = res; });
                    
                    ctx.drawImage(video, 0, 0, targetWidth, targetHeight);
                    const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
                    let brightness = 0;
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        brightness += (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                    }
                    brightness /= (imageData.data.length / 4);
                    
                    // Adaptive opacity: 15% (bright) to 25% (dark) - subtle but visible
                    const opacity = 0.15 + (0.10 * (1 - brightness / 255));
                    
                    // Watermark positioning - FULL SCREEN COVERAGE (edge to edge)
                    // Scale watermark to fill entire video frame while maintaining aspect ratio
                    const watermarkScale = Math.max(
                        targetWidth / watermark.width,   // Fill width
                        targetHeight / watermark.height  // Fill height
                    );
                    const watermarkWidth = watermark.width * watermarkScale;
                    const watermarkHeight = watermark.height * watermarkScale;
                    // Center the watermark (it will overflow edges if aspect doesn't match)
                    const watermarkX = (targetWidth - watermarkWidth) / 2;
                    const watermarkY = (targetHeight - watermarkHeight) / 2;
                    
                    // Debug logging
                    console.log(`[WATERMARK] Brand: ${brandName}, Brightness: ${brightness.toFixed(0)}, Opacity: ${(opacity*100).toFixed(0)}%`);
                    console.log(`[WATERMARK] Watermark position: X=${watermarkX.toFixed(0)}, Y=${watermarkY.toFixed(0)}, W=${watermarkWidth.toFixed(0)}, H=${watermarkHeight.toFixed(0)}`);
                    console.log(`[WATERMARK] Video duration: ${video.duration.toFixed(2)}s, Size: ${video.videoWidth}x${video.videoHeight}`);
                    
                    if (onProgress) onProgress(20);
                    
                    // Encode using MediaRecorder with preset FPS
                    const stream = canvas.captureStream ? canvas.captureStream(preset.fps) : canvas.mozCaptureStream(preset.fps);
                    console.log(`[WATERMARK] Canvas stream created: ${stream.getVideoTracks().length} video tracks at ${preset.fps}fps`);
                    
                    // BETTER AUDIO APPROACH: Capture from original video file
                    // Don't use createMediaElementSource as it breaks video playback
                    let audioTracks = [];
                    try {
                        // Create a separate video element just for audio capture
                        const audioVideo = document.createElement('video');
                        audioVideo.src = URL.createObjectURL(videoFile);
                        audioVideo.muted = false; // Keep audio enabled
                        
                        // Wait for it to load
                        await new Promise((res, rej) => {
                            audioVideo.onloadedmetadata = res;
                            audioVideo.onerror = rej;
                        });
                        
                        // Try to capture media stream from video (works on modern browsers)
                        if (audioVideo.captureStream) {
                            const audioStream = audioVideo.captureStream();
                            audioTracks = audioStream.getAudioTracks();
                            if (audioTracks.length > 0) {
                                audioTracks.forEach(track => stream.addTrack(track));
                                console.log(`[WATERMARK] ‚úì Added ${audioTracks.length} audio track(s) from video`);
                                // Play the audio video in sync
                                audioVideo.currentTime = 0;
                                audioVideo.play();
                            } else {
                                console.warn('[WATERMARK] Video has no audio tracks');
                            }
                        } else {
                            console.warn('[WATERMARK] video.captureStream() not available, video will have no audio');
                        }
                    } catch (audioErr) {
                        console.warn('[WATERMARK] Audio capture failed:', audioErr.message);
                    }
                    
                    const chunks = [];
                    // Use codec detection for best compatibility
                    const supportedCodec = getSupportedCodec();
                    const recorderOptions = { 
                        mimeType: supportedCodec, 
                        videoBitsPerSecond: preset.bitrate 
                    };
                    
                    const recorder = new MediaRecorder(stream, recorderOptions);
                    console.log('[WATERMARK] MediaRecorder created with:', recorder.mimeType, `(${(preset.bitrate/1000000).toFixed(1)}Mbps)`);
                    
                    // Store the actual mimeType for proper blob creation
                    const actualMimeType = recorder.mimeType;
                    
                    recorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
                    recorder.onstop = () => {
                        // Use actual codec type instead of forcing mp4
                        const blob = new Blob(chunks, { type: actualMimeType || 'video/webm' });
                        if (onProgress) onProgress(100);
                        resolve(blob);
                    };
                    
                    // Use timeslice for better memory management (1 second chunks)
                    recorder.start(1000);
                    video.currentTime = 0;
                    video.play();
                    
                    let frameCount = 0;
                    const totalFrames = Math.ceil(video.duration * preset.fps);
                    
                    // Render loop
                    function render() {
                        if (video.paused || video.ended) {
                            console.log(`[WATERMARK] Rendering complete. Total frames: ${frameCount}`);
                            recorder.stop();
                            video.pause();
                            return;
                        }
                        
                        frameCount++;
                        
                        // Update progress (20% -> 95% during rendering)
                        if (onProgress && frameCount % 10 === 0) {
                            const renderProgress = Math.min(95, 20 + Math.floor((frameCount / totalFrames) * 75));
                            onProgress(renderProgress);
                        }
                        
                        if (frameCount === 1 || frameCount % 30 === 0) {
                            console.log(`[WATERMARK] Frame ${frameCount}, Time: ${video.currentTime.toFixed(2)}s`);
                        }
                        
                        // Draw video frame (cropped/scaled to target aspect ratio)
                        const srcAspect = video.videoWidth / video.videoHeight;
                        const targetAspect = targetWidth / targetHeight;
                        let sx = 0, sy = 0, sw = video.videoWidth, sh = video.videoHeight;
                        
                        if (srcAspect > targetAspect) {
                            // Video wider: crop width
                            sw = video.videoHeight * targetAspect;
                            sx = (video.videoWidth - sw) / 2;
                        } else {
                            // Video taller: crop height
                            sh = video.videoWidth / targetAspect;
                            sy = (video.videoHeight - sh) / 2;
                        }
                        
                        ctx.drawImage(video, sx, sy, sw, sh, 0, 0, targetWidth, targetHeight);
                        
                        // Draw watermark with adaptive opacity
                        ctx.globalAlpha = opacity;
                        ctx.drawImage(watermark, watermarkX, watermarkY, watermarkWidth, watermarkHeight);
                        ctx.globalAlpha = 1.0;
                        
                        requestAnimationFrame(render);
                    }
                    render();
                    
                } catch (err) {
                    reject(err);
                }
            });
        }
        // ========== END PHASE B ==========
        
        // Helpers (fetch batch + paste/drag + reset)
        async function fetchBatchUrls(targetUrls) {
            const response = await fetch('/api/videos/fetch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ urls: targetUrls })
            });
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Server error (${response.status}): ${text}`);
            }
            return await response.json();
        }
        function autoDownloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'video.mp4';
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        (function(){
            const linksInput = document.getElementById('linksInput');
            const fetchStatus = document.getElementById('fetchStatus');
            const resetBtn = document.getElementById('resetLinksBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', ()=>{
                    if (linksInput) linksInput.value = '';
                    if (fetchStatus) fetchStatus.innerHTML = '';
                });
            }
            if (linksInput) {
                // Paste-to-start
                linksInput.addEventListener('paste', async (e) => {
                    const text = (e.clipboardData && e.clipboardData.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    e.preventDefault();
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download="${r.filename}">${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        } finally {
                            linksInput.value = '';
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs pasted. Tap \"Download All Links\".</div>`;
                    }
                });
                // Drag & drop URLs
                linksInput.addEventListener('dragover', (e)=>{ e.preventDefault(); linksInput.style.borderColor = '#00ff00'; });
                linksInput.addEventListener('dragleave', ()=>{ linksInput.style.borderColor = '#333'; });
                linksInput.addEventListener('drop', async (e)=>{
                    e.preventDefault(); linksInput.style.borderColor = '#333';
                    const text = (e.dataTransfer && e.dataTransfer.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download="${r.filename}">${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs dropped. Tap \"Download All Links\".</div>`;
                    }
                });
            }
        })();

        // Bulk link fetcher
        document.getElementById('fetchLinksBtn').addEventListener('click', async () => {
            const raw = (document.getElementById('linksInput').value || '').trim();
            if (!raw) {
                alert('Please paste at least one video URL');
                return;
            }
            
            const urls = raw.split('\n').map(s => s.trim()).filter(Boolean).slice(0, 5);
            const fetchStatus = document.getElementById('fetchStatus');
            
            fetchStatus.innerHTML = `<div class="status processing">‚è≥ Downloading ${urls.length} video${urls.length > 1 ? 's' : ''}...</div>`;
            document.getElementById('fetchLinksBtn').disabled = true;
            
            async function fetchBatch(targetUrls) {
                const response = await fetch('/api/videos/fetch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ urls: targetUrls })
                });
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Server error (${response.status}): ${text}`);
                }
                return await response.json();
            }
            
            try {
                let result = await fetchBatch(urls);
                if (!result.success) throw new Error(result.error || 'Fetch failed');
                let finalResults = result.results;
                
                // Auto-retry for failures (once)
                const failed = finalResults.filter(r => !r.success).map(r => r.url);
                if (failed.length) {
                    try {
                        const retry = await fetchBatch(failed);
                        if (retry.success) {
                            // Merge: replace failures with retry successes
                            finalResults = finalResults.map(r => r.success ? r : (retry.results.find(rr => rr.url === r.url) || r));
                        }
                    } catch (e) {
                        // ignore retry errors
                    }
                }
                
                const items = finalResults.map(r => {
                    if (r.success) {
                        // Save to history
                        saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                        return `<li style="margin-bottom:8px;">‚úì <a href="${r.download_url}" class="download-link" download="${r.filename}" style="color:#00ff00;">üì• ${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></li>`;
                    }
                    return `<li style="margin-bottom:8px; color:#ff5555;">‚úó ${r.url.substring(0, 50)}... ‚Äî ${r.error}</li>`;
                }).join('');
                
                fetchStatus.innerHTML = `
                    <div class="status completed">
                        ‚úì Downloaded ${finalResults.filter(r=>r.success).length}/${finalResults.length} videos:<br>
                        <ul style="margin-top:10px; text-align:left; list-style:none; padding:0;">${items}</ul>
                        <p style="margin-top:12px; font-size:12px; color:#888;">üì± Tap each link to save to your phone</p>
                        <button id="copyAllLinksBtn" style="margin-top:10px; width:100%; background:#0066ff;">üìã Copy All Download Links</button>
                    </div>
                `;
                
                // Auto-download
                if (autoDownloadEnabled) {
                    finalResults.filter(r=>r.success).forEach(r => {
                        const a = document.createElement('a');
                        a.href = r.download_url;
                        a.download = r.filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    });
                }
                
                document.getElementById('linksInput').value = '';
                loadRecentJobs();
                renderHistory();
                
            } catch (err) {
                console.error('Fetch error:', err);
                fetchStatus.innerHTML = `<div class="status failed">‚úó Error: ${err.message}</div>`;
            } finally {
                document.getElementById('fetchLinksBtn').disabled = false;
            }
        });
    </script>
</body>
</html>
