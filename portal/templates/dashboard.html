<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WatchTheFall Portal</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#00ff00">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WTF Portal">
    
    <!-- App Icons -->
    <link rel="manifest" href="/portal/static/manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23000' width='100' height='100'/%3E%3Ctext y='70' font-size='70' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect fill='%23000' width='180' height='180' rx='40'/%3E%3Ctext x='90' y='130' font-size='100' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold' text-anchor='middle'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: #111;
            padding: 20px;
            border-bottom: 2px solid #00ff00;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #00ff00;
            font-size: 24px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .section {
            background: #1a1a1a;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        
        .section h2 {
            color: #00ff00;
            font-size: 18px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .upload-zone {
            border: 2px dashed #444;
            padding: 40px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-zone:hover {
            border-color: #00ff00;
            background: #1f1f1f;
        }
        
        .upload-zone.active {
            border-color: #00ff00;
            background: #1f3f1f;
        }
        
        input[type="file"] {
            display: none;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 12px;
            background: #222;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc00;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .status.queued { background: #333; color: #aaa; }
        .status.processing { background: #1a3a4a; color: #5bc0de; }
        .status.completed { background: #1a3a1a; color: #00ff00; }
        .status.failed { background: #3a1a1a; color: #ff5555; }
        
        .job-item {
            background: #222;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #444;
        }
        
        .job-item.completed { border-left-color: #00ff00; }
        .job-item.processing { border-left-color: #5bc0de; }
        .job-item.failed { border-left-color: #ff5555; }
        
        .job-meta {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .log-entry {
            padding: 8px 12px;
            background: #1a1a1a;
            border-left: 2px solid #444;
            margin-bottom: 5px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }
        
        .log-entry.error { border-left-color: #ff5555; color: #ffaaaa; }
        .log-entry.info { border-left-color: #5bc0de; }
        
        .download-link {
            color: #00ff00;
            text-decoration: none;
            font-weight: 600;
        }
        
        .download-link:hover {
            text-decoration: underline;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .section {
                padding: 15px;
            }
            
            h1 {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>‚ö° WatchTheFall Portal</h1>
            <div class="subtitle">Video Processing & Automation Control Panel</div>
        </div>
    </header>
    
    <div class="container">
        <!-- Multi-Link Downloader Section -->
        <div class="section">
            <h2>üîó Bulk Download (Paste Links)</h2>
            <p style="color: #888; font-size: 14px; margin-bottom: 15px;">Paste up to 5 TikTok, Instagram, or X links (one per line) - videos download directly to your phone</p>
            
            <textarea id="linksInput" placeholder="https://tiktok.com/@user/video/123...&#10;https://instagram.com/reel/abc...&#10;https://x.com/user/status/456..." 
                style="width:100%; min-height:120px; background:#111; border:1px solid #333; color:#ddd; padding:12px; border-radius:8px; font-size:14px; font-family:monospace; resize:vertical;"></textarea>
            
            <div style="display:flex; gap:10px; margin-top:12px;">
                <button id="fetchLinksBtn" style="flex:1; background:#00aa00;">üì• Download All Links</button>
                <button id="pasteClipboardBtn" style="flex:1; background:#0066ff;">üìã Paste from Clipboard</button>
                <button id="resetLinksBtn" style="flex:1; background:#444;">‚ôª Reset</button>
            </div>
            <label style="display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px; color:#aaa;">
                <input type="checkbox" id="autoDownloadToggle"> Auto-download when ready
            </label>
            
            <div id="fetchStatus" style="margin-top:15px;"></div>
        </div>
        
        <!-- Upload Section -->
        <div class="section">
            <h2>üì§ Upload & Process</h2>
            
            <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                <div id="uploadText">
                    <p style="font-size: 18px; margin-bottom: 10px;">üìÅ Click or drag video here</p>
                    <p style="color: #888; font-size: 14px;">Supported: MP4, MOV, AVI (max 500MB)</p>
                </div>
            </div>
            <input type="file" id="fileInput" accept="video/mp4,video/quicktime,video/x-msvideo">
            
            <div style="margin-top: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #aaa; font-size: 14px;">Template</label>
                <select id="templateSelect">
                    <option value="">Loading templates...</option>
                </select>
                
                <label style="display: block; margin-bottom: 8px; margin-top: 15px; color: #aaa; font-size: 14px;">Aspect Ratio</label>
                <select id="aspectRatioSelect">
                    <option value="9:16">9:16 (TikTok/Reels)</option>
                    <option value="1:1">1:1 (Square)</option>
                    <option value="16:9">16:9 (YouTube)</option>
                </select>
                
                <button id="processBtn" style="width: 100%; margin-top: 20px;" disabled>Process Video</button>
            </div>
            
            <div id="statusMessage" style="margin-top: 15px;"></div>
        </div>
        
        <div class="grid">
            <!-- Recent Jobs -->
            <div class="section">
                <h2>üìä Recent Jobs</h2>
                <div id="recentJobs">
                    <p style="color: #666;">No jobs yet</p>
                </div>
            </div>
            
            <!-- System Logs -->
            <div class="section">
                <h2>üìú System Logs</h2>
                <div id="systemLogs" style="max-height: 400px; overflow-y: auto;">
                    <p style="color: #666;">Loading logs...</p>
                </div>
            </div>
            
            <!-- History -->
            <div class="section">
                <h2>üïò History</h2>
                <div id="historyList">
                    <p style="color: #666;">No history yet</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let uploadedFilename = null;
        let activeJobId = null;
        let statusPollInterval = null;
        
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/portal/static/sw.js').catch(() => {});
        }
        
        // Auto-download toggle
        let autoDownloadEnabled = false;
        document.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('autoDownloadToggle');
            if (toggle) {
                toggle.addEventListener('change', (e) => {
                    autoDownloadEnabled = !!e.target.checked;
                });
            }
        });
        
        // Paste-All button
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.id === 'pasteClipboardBtn') {
                if (!navigator.clipboard) return;
                try {
                    const text = await navigator.clipboard.readText();
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) {
                        alert('No URLs found in clipboard');
                        return;
                    }
                    document.getElementById('linksInput').value = urls.join('\n');
                    document.getElementById('fetchStatus').innerHTML = '<div class="status queued">üìã Pasted URLs from clipboard.</div>';
                } catch (err) {
                    alert('Clipboard read failed');
                }
            }
        });
        
        // Helpers
        function extractURLs(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return (text.match(urlRegex) || []).map(u => u.trim());
        }
        
        async function shareVideo(downloadUrl, filename) {
            try {
                if (!navigator.share) {
                    alert('Sharing not supported on this browser');
                    return;
                }
                const res = await fetch(downloadUrl);
                const blob = await res.blob();
                const file = new File([blob], filename || 'video.mp4', { type: 'video/mp4' });
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({ files: [file], title: filename || 'Video' });
                } else {
                    // Fallback: share URL
                    await navigator.share({ title: filename || 'Video', url: downloadUrl });
                }
            } catch (e) {
                alert('Share failed: ' + e.message);
            }
        }
        
        // Delegate click for share buttons and copy-all-links
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.classList.contains('share-btn')) {
                const url = e.target.getAttribute('data-url');
                const name = e.target.getAttribute('data-filename') || 'video.mp4';
                await shareVideo(url, name);
            }
            if (e.target && e.target.id === 'copyAllLinksBtn') {
                const links = [];
                document.querySelectorAll('.download-link').forEach(a => {
                    if (a.href) links.push(a.href);
                });
                if (links.length) {
                    try {
                        await navigator.clipboard.writeText(links.join('\n'));
                        e.target.textContent = '‚úì Copied!';
                        setTimeout(() => { e.target.textContent = 'üìã Copy All Download Links'; }, 2000);
                    } catch (err) {
                        alert('Copy failed: ' + err.message);
                    }
                } else {
                    alert('No download links found');
                }
            }
        });
        
        function saveHistoryEntry(entry) {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            hist.unshift({ ...entry, ts: Date.now() });
            hist = hist.slice(0,20);
            localStorage.setItem(key, JSON.stringify(hist));
            renderHistory();
        }
        function renderHistory() {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            const container = document.getElementById('historyList');
            if (!container) return;
            if (!hist.length) {
                container.innerHTML = '<p style="color:#666;">No history yet</p>';
                return;
            }
            container.innerHTML = hist.map(h => `
                <div class="job-item">
                    <strong>${h.name || h.filename || 'Video'}</strong>
                    <div class="job-meta">${new Date(h.ts).toLocaleString()}${h.size_mb ? ` ‚Ä¢ ${h.size_mb}MB` : ''}
                    ${h.url ? `<br><a href="${h.url}" class="download-link" download>Download</a> <button class="share-btn" data-url="${h.url}" data-filename="${h.name || 'video.mp4'}" style="margin-left:8px;">ü§ù Share to CapCut</button>` : ''}</div>
                </div>
            `).join('');
        }
        
        // Load templates
        fetch('/api/templates')
            .then(r => r.json())
            .then(data => {
                const select = document.getElementById('templateSelect');
                select.innerHTML = data.templates.map(t => 
                    `<option value="${t.name}">${t.display_name}</option>`
                ).join('');
            });
        
        // File upload
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const uploadZone = document.getElementById('uploadZone');
            const uploadText = document.getElementById('uploadText');
            
            uploadText.innerHTML = '<p>‚è≥ Uploading...</p>';
            uploadZone.classList.add('active');
            
            const formData = new FormData();
            formData.append('video', file);
            
            try {
                const response = await fetch('/api/videos/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    uploadedFilename = result.filename;
                    uploadText.innerHTML = `<p style="color: #00ff00;">‚úì ${file.name}</p><p style="font-size: 12px; color: #888; margin-top: 5px;">Ready to process</p>`;
                    document.getElementById('processBtn').disabled = false;
                } else {
                    throw new Error(result.error);
                }
            } catch (err) {
                uploadText.innerHTML = `<p style="color: #ff5555;">‚úó Upload failed: ${err.message}</p>`;
                uploadZone.classList.remove('active');
            }
        });
        
        // Helpers (fetch batch + paste/drag + reset)
        async function fetchBatchUrls(targetUrls) {
            const response = await fetch('/api/videos/fetch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ urls: targetUrls })
            });
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Server error (${response.status}): ${text}`);
            }
            return await response.json();
        }
        function autoDownloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'video.mp4';
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        (function(){
            const linksInput = document.getElementById('linksInput');
            const fetchStatus = document.getElementById('fetchStatus');
            const resetBtn = document.getElementById('resetLinksBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', ()=>{
                    if (linksInput) linksInput.value = '';
                    if (fetchStatus) fetchStatus.innerHTML = '';
                });
            }
            if (linksInput) {
                // Paste-to-start
                linksInput.addEventListener('paste', async (e) => {
                    const text = (e.clipboardData && e.clipboardData.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    e.preventDefault();
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download>${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share to CapCut</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        } finally {
                            linksInput.value = '';
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs pasted. Tap \"Download All Links\".</div>`;
                    }
                });
                // Drag & drop URLs
                linksInput.addEventListener('dragover', (e)=>{ e.preventDefault(); linksInput.style.borderColor = '#00ff00'; });
                linksInput.addEventListener('dragleave', ()=>{ linksInput.style.borderColor = '#333'; });
                linksInput.addEventListener('drop', async (e)=>{
                    e.preventDefault(); linksInput.style.borderColor = '#333';
                    const text = (e.dataTransfer && e.dataTransfer.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download>${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share to CapCut</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs dropped. Tap \"Download All Links\".</div>`;
                    }
                });
            }
        })();

        // Bulk link fetcher
        document.getElementById('fetchLinksBtn').addEventListener('click', async () => {
            const raw = (document.getElementById('linksInput').value || '').trim();
            if (!raw) {
                alert('Please paste at least one video URL');
                return;
            }
            
            const urls = raw.split('\n').map(s => s.trim()).filter(Boolean).slice(0, 5);
            const fetchStatus = document.getElementById('fetchStatus');
            
            fetchStatus.innerHTML = `<div class="status processing">‚è≥ Downloading ${urls.length} video${urls.length > 1 ? 's' : ''}...</div>`;
            document.getElementById('fetchLinksBtn').disabled = true;
            
            async function fetchBatch(targetUrls) {
                const response = await fetch('/api/videos/fetch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ urls: targetUrls })
                });
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Server error (${response.status}): ${text}`);
                }
                return await response.json();
            }
            
            try {
                let result = await fetchBatch(urls);
                if (!result.success) throw new Error(result.error || 'Fetch failed');
                let finalResults = result.results;
                
                // Auto-retry for failures (once)
                const failed = finalResults.filter(r => !r.success).map(r => r.url);
                if (failed.length) {
                    try {
                        const retry = await fetchBatch(failed);
                        if (retry.success) {
                            // Merge: replace failures with retry successes
                            finalResults = finalResults.map(r => r.success ? r : (retry.results.find(rr => rr.url === r.url) || r));
                        }
                    } catch (e) {
                        // ignore retry errors
                    }
                }
                
                const items = finalResults.map(r => {
                    if (r.success) {
                        // Save to history
                        saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                        return `<li style="margin-bottom:8px;">‚úì <a href="${r.download_url}" class="download-link" download style="color:#00ff00;">${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share to CapCut</button></li>`;
                    }
                    return `<li style="margin-bottom:8px; color:#ff5555;">‚úó ${r.url.substring(0, 50)}... ‚Äî ${r.error}</li>`;
                }).join('');
                
                fetchStatus.innerHTML = `
                    <div class="status completed">
                        ‚úì Downloaded ${finalResults.filter(r=>r.success).length}/${finalResults.length} videos:<br>
                        <ul style="margin-top:10px; text-align:left; list-style:none; padding:0;">${items}</ul>
                        <p style="margin-top:12px; font-size:12px; color:#888;">üì± Tap each link to save to your phone</p>
                        <button id="copyAllLinksBtn" style="margin-top:10px; width:100%; background:#0066ff;">üìã Copy All Download Links</button>
                    </div>
                `;
                
                // Auto-download
                if (autoDownloadEnabled) {
                    finalResults.filter(r=>r.success).forEach(r => {
                        const a = document.createElement('a');
                        a.href = r.download_url;
                        a.download = r.filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    });
                }
                
                document.getElementById('linksInput').value = '';
                loadRecentJobs();
                renderHistory();
                
            } catch (err) {
                console.error('Fetch error:', err);
                fetchStatus.innerHTML = `<div class="status failed">‚úó Error: ${err.message}</div>`;
            } finally {
                document.getElementById('fetchLinksBtn').disabled = false;
            }
        });
        
        // Process video
        document.getElementById('processBtn').addEventListener('click', async () => {
            if (!uploadedFilename) return;
            
            // Clear any existing status polling
            if (statusPollInterval) {
                clearInterval(statusPollInterval);
                statusPollInterval = null;
            }
            
            const template = document.getElementById('templateSelect').value;
            const aspectRatio = document.getElementById('aspectRatioSelect').value;
            const statusDiv = document.getElementById('statusMessage');
            
            statusDiv.innerHTML = '<div class="status processing">‚è≥ Processing video...</div>';
            document.getElementById('processBtn').disabled = true;
            
            async function tryProcess(retries = 2) {
                try {
                    const response = await fetch('/api/videos/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: uploadedFilename,
                            template: template,
                            aspect_ratio: aspectRatio
                        })
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Server error (${response.status}): ${errorText}`);
                    }
                    const text = await response.text();
                    if (!text || text.trim() === '') throw new Error('Backend returned empty response');
                    const result = JSON.parse(text);
                    if (!result.success) throw new Error(result.error || 'Processing failed');
                    activeJobId = result.job_id;
                    statusDiv.innerHTML = `<div class=\"status processing\">Processing... Job ID: ${result.job_id}</div>`;
                    pollJobStatus(result.job_id);
                } catch (err) {
                    if (retries > 0) {
                        statusDiv.innerHTML = `<div class=\"status queued\">Retrying... (${retries})</div>`;
                        await new Promise(res => setTimeout(res, 1000));
                        return tryProcess(retries - 1);
                    }
                    console.error('Process error:', err);
                    statusDiv.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                    document.getElementById('processBtn').disabled = false;
                }
            }
            
            tryProcess();
        });
        
        // Poll job status
        function pollJobStatus(jobId) {
            // Clear any existing interval
            if (statusPollInterval) {
                clearInterval(statusPollInterval);
            }
            
            statusPollInterval = setInterval(async () => {
                // Only poll if this is still the active job
                if (activeJobId !== jobId) {
                    clearInterval(statusPollInterval);
                    return;
                }
                
                try {
                    const response = await fetch(`/api/videos/status/${jobId}`);
                    const job = await response.json();
                    
                    const statusDiv = document.getElementById('statusMessage');
                    
                    if (job.status === 'completed') {
                        clearInterval(statusPollInterval);
                        statusPollInterval = null;
                        statusDiv.innerHTML = `
                            <div class=\"status completed\">\n                                ‚úì Processing complete!<br>\n                                <a href=\"${job.download_url}\" class=\"download-link\" download>üì• Download ${job.output_file}</a> <button class=\"share-btn\" data-url=\"${job.download_url}\" data-filename=\"${job.output_file}\" style=\"margin-left:10px;\">ü§ù Share to CapCut</button>\n                            </div>
                        `;
                        loadRecentJobs();
                        // Save history
                        saveHistoryEntry({ type: 'process', name: job.output_file, url: job.download_url });
                        // Auto-download
                        if (autoDownloadEnabled && job.download_url) {
                            const a = document.createElement('a');
                            a.href = job.download_url;
                            a.download = job.output_file || 'video.mp4';
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                        }
                        renderHistory();
                        resetUpload();
                    } else if (job.status === 'failed') {
                        clearInterval(statusPollInterval);
                        statusPollInterval = null;
                        statusDiv.innerHTML = `<div class=\"status failed\">‚úó Processing failed: ${job.error || 'Unknown error'}</div>`;
                        resetUpload();
                    } else {
                        // Still processing - update status message
                        statusDiv.innerHTML = `<div class=\"status processing\">‚è≥ Processing... Job ID: ${jobId}</div>`;
                    }
                } catch (err) {
                    console.error('Status poll error:', err);
                    clearInterval(statusPollInterval);
                    statusPollInterval = null;
                }
            }, 2000);
        }
        
        // Reset upload
        function resetUpload() {
            uploadedFilename = null;
            activeJobId = null;
            document.getElementById('processBtn').disabled = false;
            document.getElementById('uploadText').innerHTML = `
                <p style="font-size: 18px; margin-bottom: 10px;">üìÅ Click or drag video here</p>
                <p style="color: #888; font-size: 14px;">Supported: MP4, MOV, AVI (max 500MB)</p>
            `;
            document.getElementById('uploadZone').classList.remove('active');
            document.getElementById('fileInput').value = '';
        }
        
        // Load recent jobs
        function loadRecentJobs() {
            fetch('/api/videos/recent?limit=10')
                .then(r => r.json())
                .then(data => {
                    const container = document.getElementById('recentJobs');
                    if (data.jobs.length === 0) {
                        container.innerHTML = '<p style="color: #666;">No jobs yet</p>';
                        return;
                    }
                    
                    container.innerHTML = data.jobs.map(job => `
                        <div class="job-item ${job.status}">
                            <strong>${job.template}</strong> 
                            <span class="status ${job.status}" style="display: inline-block; padding: 2px 8px; font-size: 11px; margin-left: 10px;">${job.status}</span>
                            <div class="job-meta">
                                ${job.aspect_ratio} ‚Ä¢ ${new Date(job.created_at).toLocaleString()}
                                ${job.status === 'completed' ? `<br><a href="/api/videos/download/${job.output_path}" class="download-link">Download</a>` : ''}
                            </div>
                        </div>
                    `).join('');
                });
        }
        
        // Load system logs
        function loadSystemLogs() {
            fetch('/api/system/logs?limit=20')
                .then(r => r.json())
                .then(data => {
                    const container = document.getElementById('systemLogs');
                    if (data.logs.length === 0) {
                        container.innerHTML = '<p style="color: #666;">No logs yet</p>';
                        return;
                    }
                    
                    container.innerHTML = data.logs.map(log => `
                        <div class="log-entry ${log.level}">
                            <span style="color: #666;">[${new Date(log.timestamp).toLocaleTimeString()}]</span>
                            ${log.message}
                        </div>
                    `).join('');
                });
        }
        
        // Auto-refresh
        loadRecentJobs();
        loadSystemLogs();
        setInterval(loadRecentJobs, 5000);
        setInterval(loadSystemLogs, 10000);
    </script>
</body>
</html>
