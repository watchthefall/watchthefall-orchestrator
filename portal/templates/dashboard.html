<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WatchTheFall Portal</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#00ff00">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WTF Portal">
    
    <!-- App Icons -->
    <link rel="manifest" href="/portal/static/manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23000' width='100' height='100'/%3E%3Ctext y='70' font-size='70' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect fill='%23000' width='180' height='180' rx='40'/%3E%3Ctext x='90' y='130' font-size='100' fill='%2300ff00' font-family='Arial,sans-serif' font-weight='bold' text-anchor='middle'%3E‚ö°%3C/text%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: #111;
            padding: 20px;
            border-bottom: 2px solid #00ff00;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #00ff00;
            font-size: 24px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #888;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .section {
            background: #1a1a1a;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        
        .section h2 {
            color: #00ff00;
            font-size: 18px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .upload-zone {
            border: 2px dashed #444;
            padding: 40px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-zone:hover {
            border-color: #00ff00;
            background: #1f1f1f;
        }
        
        .upload-zone.active {
            border-color: #00ff00;
            background: #1f3f1f;
        }
        
        input[type="file"] {
            display: none;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 12px;
            background: #222;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 15px;
        }
        
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc00;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            margin: 10px 0;
        }
        
        .status.queued { background: #333; color: #aaa; }
        .status.processing { background: #1a3a4a; color: #5bc0de; }
        .status.completed { background: #1a3a1a; color: #00ff00; }
        .status.failed { background: #3a1a1a; color: #ff5555; }
        
        .job-item {
            background: #222;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #444;
        }
        
        .job-item.completed { border-left-color: #00ff00; }
        .job-item.processing { border-left-color: #5bc0de; }
        .job-item.failed { border-left-color: #ff5555; }
        
        .job-meta {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .log-entry {
            padding: 8px 12px;
            background: #1a1a1a;
            border-left: 2px solid #444;
            margin-bottom: 5px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }
        
        .log-entry.error { border-left-color: #ff5555; color: #ffaaaa; }
        .log-entry.info { border-left-color: #5bc0de; }
        
        .download-link {
            color: #00ff00;
            text-decoration: none;
            font-weight: 600;
        }
        
        .download-link:hover {
            text-decoration: underline;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .section {
                padding: 15px;
            }
            
            h1 {
                font-size: 20px;
            }
        }
        
        /* Brand watermark styles */
        .brand-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }
        .brand-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #222;
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #333;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
        }
        .brand-checkbox:hover {
            background: #2a2a2a;
            border-color: #00ff00;
        }
        .brand-checkbox input[type="checkbox"] {
            cursor: pointer;
        }
        .brand-checkbox input[type="checkbox"]:checked + span {
            color: #00ff00;
            font-weight: 600;
        }
        #watermarkStatus {
            margin-top: 15px;
        }
        .watermark-result {
            background: #222;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #00ff00;
        }
        
        /* Brand selector modal */
        .brand-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            overflow-y: auto;
        }
        .brand-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .brand-modal-content {
            background: #1a1a1a;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .brand-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .brand-modal-close {
            background: #444;
            color: #fff;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }
        .brand-modal-close:hover {
            background: #ff5555;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>‚ö° WatchTheFall Portal</h1>
            <div class="subtitle">Video Processing & Automation Control Panel</div>
        </div>
    </header>
    
    <div class="container">
        <!-- Multi-Link Downloader Section -->
        <div class="section">
            <h2>üîó Bulk Download (Paste Links)</h2>
            <p style="color: #888; font-size: 14px; margin-bottom: 15px;">Paste up to 5 TikTok, Instagram, or X links (one per line) - videos download directly to your phone</p>
            
            <textarea id="linksInput" placeholder="https://tiktok.com/@user/video/123...&#10;https://instagram.com/reel/abc...&#10;https://x.com/user/status/456..." 
                style="width:100%; min-height:120px; background:#111; border:1px solid #333; color:#ddd; padding:12px; border-radius:8px; font-size:14px; font-family:monospace; resize:vertical;"></textarea>
            
            <div style="display:flex; gap:10px; margin-top:12px;">
                <button id="fetchLinksBtn" style="flex:1; background:#00aa00;">üì• Download All Links</button>
                <button id="pasteClipboardBtn" style="flex:1; background:#0066ff;">üìã Paste from Clipboard</button>
                <button id="resetLinksBtn" style="flex:1; background:#444;">‚ôª Reset</button>
            </div>
            <label style="display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px; color:#aaa;">
                <input type="checkbox" id="autoDownloadToggle"> Auto-download when ready
            </label>
            
            <div id="fetchStatus" style="margin-top:15px;"></div>
        </div>
        
        <!-- Brand Watermark Section -->
        <div class="section">
            <h2>üé® Brand Watermark (Client-Side)</h2>
            <p style="color: #888; font-size: 14px; margin-bottom: 15px;">Select video from downloads or upload new ‚Ä¢ Choose brands ‚Ä¢ Get watermarked 9:16 versions instantly</p>
            
            <input type="file" id="watermarkVideoInput" accept="video/mp4,video/quicktime" style="display:none;">
            <button id="selectVideoBtn" style="width:100%; background:#0066ff; margin-bottom:15px;">üìÇ Select Video File</button>
            <div id="selectedVideoName" style="color:#aaa; font-size:13px; margin-bottom:15px;"></div>
            
            <label style="display:block; margin-bottom:8px; color:#aaa; font-size:14px; font-weight:600;">Select Brands (up to 10):</label>
            <div class="brand-grid" id="brandGrid">
                <!-- Brands loaded dynamically -->
            </div>
            
            <button id="applyWatermarksBtn" style="width:100%; margin-top:20px; background:#00aa00;" disabled>‚ö° Generate Watermarked Videos</button>
            
            <div id="watermarkStatus"></div>
        </div>
        
        <!-- Upload Section -->
        <div class="section">
            <h2>üì§ Upload & Process</h2>
            
            <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                <div id="uploadText">
                    <p style="font-size: 18px; margin-bottom: 10px;">üìÅ Click or drag video here</p>
                    <p style="color: #888; font-size: 14px;">Supported: MP4, MOV, AVI (max 500MB)</p>
                </div>
            </div>
            <input type="file" id="fileInput" accept="video/mp4,video/quicktime,video/x-msvideo">
            
            <div style="margin-top: 20px;">
                <label style="display: block; margin-bottom: 8px; color: #aaa; font-size: 14px;">Template</label>
                <select id="templateSelect">
                    <option value="">Loading templates...</option>
                </select>
                
                <label style="display: block; margin-bottom: 8px; margin-top: 15px; color: #aaa; font-size: 14px;">Aspect Ratio</label>
                <select id="aspectRatioSelect">
                    <option value="9:16">9:16 (TikTok/Reels)</option>
                    <option value="1:1">1:1 (Square)</option>
                    <option value="16:9">16:9 (YouTube)</option>
                </select>
                
                <button id="processBtn" style="width: 100%; margin-top: 20px;" disabled>Process Video</button>
            </div>
            
            <div id="statusMessage" style="margin-top: 15px;"></div>
        </div>
        
        <div class="grid">
            <!-- Recent Jobs -->
            <div class="section">
                <h2>üìä Recent Jobs</h2>
                <div id="recentJobs">
                    <p style="color: #666;">No jobs yet</p>
                </div>
            </div>
            
            <!-- System Logs -->
            <div class="section">
                <h2>üìú System Logs</h2>
                <div id="systemLogs" style="max-height: 400px; overflow-y: auto;">
                    <p style="color: #666;">Loading logs...</p>
                </div>
            </div>
            
            <!-- History -->
            <div class="section">
                <h2>üïò History</h2>
                <div id="historyList">
                    <p style="color: #666;">No history yet</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Brand Selector Modal -->
    <div id="brandModal" class="brand-modal">
        <div class="brand-modal-content">
            <div class="brand-modal-header">
                <h3 style="color:#00ff00; margin:0;">üé® Select Brands for Watermarking</h3>
                <button class="brand-modal-close" onclick="closeBrandModal()">√ó</button>
            </div>
            <div id="modalVideoName" style="color:#aaa; font-size:13px; margin-bottom:15px;"></div>
            <p style="color:#888; font-size:14px; margin-bottom:15px;">Choose up to 10 brands to watermark this video. Each will be downloaded separately.</p>
            <div class="brand-grid" id="modalBrandGrid">
                <p style="color:#666;">Loading brands...</p>
            </div>
            <div style="margin-top:20px; display:flex; gap:10px;">
                <button id="modalGenerateBtn" style="flex:1; background:#00aa00;" disabled>‚ö° Generate Watermarked Videos</button>
                <button onclick="closeBrandModal()" style="flex:1; background:#444;">‚ùå Cancel</button>
            </div>
            <div id="modalStatus" style="margin-top:15px;"></div>
        </div>
    </div>
    
    <script>
        let uploadedFilename = null;
        let activeJobId = null;
        let statusPollInterval = null;
        
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/portal/static/sw.js').catch(() => {});
        }
        
        // Auto-download toggle
        let autoDownloadEnabled = false;
        document.addEventListener('DOMContentLoaded', () => {
            const toggle = document.getElementById('autoDownloadToggle');
            if (toggle) {
                toggle.addEventListener('change', (e) => {
                    autoDownloadEnabled = !!e.target.checked;
                });
            }
        });
        
        // Paste-All button
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.id === 'pasteClipboardBtn') {
                if (!navigator.clipboard) return;
                try {
                    const text = await navigator.clipboard.readText();
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) {
                        alert('No URLs found in clipboard');
                        return;
                    }
                    document.getElementById('linksInput').value = urls.join('\n');
                    document.getElementById('fetchStatus').innerHTML = '<div class="status queued">üìã Pasted URLs from clipboard.</div>';
                } catch (err) {
                    alert('Clipboard read failed');
                }
            }
        });
        
        // Helpers
        function extractURLs(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return (text.match(urlRegex) || []).map(u => u.trim());
        }
        
        async function shareVideo(downloadUrl, filename) {
            try {
                if (!navigator.share) {
                    alert('Sharing not supported on this browser');
                    return;
                }
                const res = await fetch(downloadUrl);
                const blob = await res.blob();
                const file = new File([blob], filename || 'video.mp4', { type: 'video/mp4' });
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({ files: [file], title: filename || 'Video' });
                } else {
                    // Fallback: share URL
                    await navigator.share({ title: filename || 'Video', url: downloadUrl });
                }
            } catch (e) {
                alert('Share failed: ' + e.message);
            }
        }
        
        // Delegate click for share buttons and copy-all-links
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.classList.contains('share-btn')) {
                const url = e.target.getAttribute('data-url');
                const name = e.target.getAttribute('data-filename') || 'video.mp4';
                await shareVideo(url, name);
            }
            if (e.target && e.target.id === 'copyAllLinksBtn') {
                const links = [];
                document.querySelectorAll('.download-link').forEach(a => {
                    if (a.href) links.push(a.href);
                });
                if (links.length) {
                    try {
                        await navigator.clipboard.writeText(links.join('\n'));
                        e.target.textContent = '‚úì Copied!';
                        setTimeout(() => { e.target.textContent = 'üìã Copy All Download Links'; }, 2000);
                    } catch (err) {
                        alert('Copy failed: ' + err.message);
                    }
                } else {
                    alert('No download links found');
                }
            }
        });
        
        function saveHistoryEntry(entry) {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            hist.unshift({ ...entry, ts: Date.now() });
            hist = hist.slice(0,20);
            localStorage.setItem(key, JSON.stringify(hist));
            renderHistory();
        }
        function renderHistory() {
            const key = 'wtf_history';
            let hist = [];
            try { hist = JSON.parse(localStorage.getItem(key) || '[]'); } catch {}
            const container = document.getElementById('historyList');
            if (!container) return;
            if (!hist.length) {
                container.innerHTML = '<p style="color:#666;">No history yet</p>';
                return;
            }
            container.innerHTML = hist.map(h => `
                <div class="job-item">
                    <strong>${h.name || h.filename || 'Video'}</strong>
                    <div class="job-meta">${new Date(h.ts).toLocaleString()}${h.size_mb ? ` ‚Ä¢ ${h.size_mb}MB` : ''}
                    ${h.url ? `<br><a href="${h.url}" class="download-link" download="${h.name || 'video.mp4'}">üì• Download</a> <button class="share-btn" data-url="${h.url}" data-filename="${h.name || 'video.mp4'}" style="margin-left:8px;">ü§ù Share</button>` : ''}</div>
                </div>
            `).join('');
        }
        
        // Load templates
        fetch('/api/templates')
            .then(r => r.json())
            .then(data => {
                const select = document.getElementById('templateSelect');
                select.innerHTML = data.templates.map(t => 
                    `<option value="${t.name}">${t.display_name}</option>`
                ).join('');
            });
        
        // ========== PHASE B: CLIENT-SIDE WATERMARK SYSTEM ==========
        let selectedVideoFile = null;
        let brandWatermarks = {};
        let brandsLoaded = false;
        let pendingVideoBlob = null;
        let pendingVideoFilename = null;
        
        // Brand modal functions
        function closeBrandModal() {
            document.getElementById('brandModal').classList.remove('active');
            document.querySelectorAll('.modal-brand-check').forEach(cb => cb.checked = false);
            document.getElementById('modalStatus').innerHTML = '';
            pendingVideoBlob = null;
            pendingVideoFilename = null;
        }
        
        async function openBrandModalForUrl(videoUrl, filename) {
            try {
                console.log('[MODAL] Opening brand modal for:', filename);
                console.log('[MODAL] Brands loaded:', brandsLoaded);
                console.log('[MODAL] Brand count:', Object.keys(brandWatermarks).length);
                
                // Wait for brands to load first
                if (!brandsLoaded) {
                    alert('Loading brands... please wait a moment and try again.');
                    return;
                }
                
                // Fetch video as blob
                document.getElementById('modalVideoName').textContent = `üé¨ Loading: ${filename}...`;
                document.getElementById('brandModal').classList.add('active');
                
                // Debug: Check if grid has content
                const gridHTML = document.getElementById('modalBrandGrid').innerHTML;
                console.log('[MODAL] Grid HTML length:', gridHTML.length);
                console.log('[MODAL] Grid first 200 chars:', gridHTML.substring(0, 200));
                
                const response = await fetch(videoUrl);
                if (!response.ok) throw new Error('Failed to load video');
                
                pendingVideoBlob = await response.blob();
                pendingVideoFilename = filename;
                
                document.getElementById('modalVideoName').textContent = `üé¨ ${filename} (${(pendingVideoBlob.size/(1024*1024)).toFixed(2)}MB)`;
            } catch (err) {
                console.error('[MODAL] Error:', err);
                alert('Failed to load video: ' + err.message);
                closeBrandModal();
            }
        }
        
        // Intercept download link clicks
        document.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('download-link')) {
                e.preventDefault();
                const url = e.target.getAttribute('href');
                const filename = e.target.getAttribute('download') || 'video.mp4';
                openBrandModalForUrl(url, filename);
            }
        });
        
        // Load brand watermarks config
        fetch('/portal/static/watermarks/brands.json')
            .then(r => r.json())
            .then(brands => {
                brandWatermarks = brands;
                
                // Populate main brand grid
                const grid = document.getElementById('brandGrid');
                grid.innerHTML = Object.keys(brands).map((brandName, idx) => `
                    <label class="brand-checkbox">
                        <input type="checkbox" class="brand-check" value="${brandName}" data-file="${brands[brandName]}">
                        <span>${brandName}</span>
                    </label>
                `).join('');
                
                // Populate modal brand grid
                const modalGrid = document.getElementById('modalBrandGrid');
                modalGrid.innerHTML = Object.keys(brands).map((brandName, idx) => `
                    <label class="brand-checkbox">
                        <input type="checkbox" class="modal-brand-check" value="${brandName}" data-file="${brands[brandName]}">
                        <span>${brandName}</span>
                    </label>
                `).join('');
                
                console.log(`[BRANDS] Loaded ${Object.keys(brands).length} brands into modal grid`);
                brandsLoaded = true;
                
                // Enable/disable button based on selection (main section)
                document.querySelectorAll('.brand-check').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const selected = document.querySelectorAll('.brand-check:checked').length;
                        const applyBtn = document.getElementById('applyWatermarksBtn');
                        applyBtn.disabled = !(selectedVideoFile && selected > 0 && selected <= 10);
                        if (selected > 10) {
                            alert('Maximum 10 brands at a time');
                            cb.checked = false;
                        }
                    });
                });
                
                // Enable/disable button based on selection (modal)
                document.querySelectorAll('.modal-brand-check').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const selected = document.querySelectorAll('.modal-brand-check:checked').length;
                        const generateBtn = document.getElementById('modalGenerateBtn');
                        generateBtn.disabled = !(selected > 0 && selected <= 10);
                        if (selected > 10) {
                            alert('Maximum 10 brands at a time');
                            cb.checked = false;
                        }
                    });
                });
            })
            .catch(err => {
                console.error('[BRANDS] Failed to load brands.json:', err);
                alert('Failed to load brand list. Please refresh the page.');
            });
        
        // Modal Generate button handler
        document.getElementById('modalGenerateBtn').addEventListener('click', async () => {
            const selected = Array.from(document.querySelectorAll('.modal-brand-check:checked'));
            if (!pendingVideoBlob || !selected.length) return;
            
            const statusDiv = document.getElementById('modalStatus');
            statusDiv.innerHTML = '<div class="status processing">‚è≥ Processing watermarks...</div>';
            document.getElementById('modalGenerateBtn').disabled = true;
            
            const results = [];
            
            for (let i = 0; i < selected.length; i++) {
                const brandName = selected[i].value;
                const watermarkFile = selected[i].getAttribute('data-file');
                
                try {
                    statusDiv.innerHTML = `<div class="status processing">‚è≥ Processing ${i+1}/${selected.length}: ${brandName}...</div>`;
                    
                    const videoFile = new File([pendingVideoBlob], pendingVideoFilename, { type: pendingVideoBlob.type });
                    const watermarkedBlob = await applyWatermarkToVideo(videoFile, watermarkFile, brandName);
                    const url = URL.createObjectURL(watermarkedBlob);
                    const filename = `${brandName}_${pendingVideoFilename.replace(/\.[^/.]+$/, '')}.mp4`;
                    
                    results.push({ brandName, url, filename, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                    // Save to history
                    saveHistoryEntry({ type: 'watermark', name: filename, url, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                } catch (err) {
                    results.push({ brandName, error: err.message });
                }
            }
            
            // Show results
            const successCount = results.filter(r => !r.error).length;
            const items = results.map(r => {
                if (r.error) {
                    return `<div class="watermark-result" style="border-left-color:#ff5555;">‚úó ${r.brandName}: ${r.error}</div>`;
                }
                return `<div class="watermark-result">‚úì <strong>${r.brandName}</strong><br><a href="${r.url}" download="${r.filename}" style="color:#00ff00;">üì• ${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
            }).join('');
            
            statusDiv.innerHTML = `<div class="status completed">‚úì Generated ${successCount}/${results.length} watermarked videos</div>${items}`;
            
            // Auto-download if enabled
            if (autoDownloadEnabled) {
                results.filter(r => !r.error).forEach(r => {
                    const a = document.createElement('a');
                    a.href = r.url;
                    a.download = r.filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                });
            }
            
            renderHistory();
            document.getElementById('modalGenerateBtn').disabled = false;
        });
        
        // Select video file
        document.getElementById('selectVideoBtn').addEventListener('click', () => {
            document.getElementById('watermarkVideoInput').click();
        });
        
        document.getElementById('watermarkVideoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            selectedVideoFile = file;
            document.getElementById('selectedVideoName').textContent = `‚úì Selected: ${file.name} (${(file.size/(1024*1024)).toFixed(2)}MB)`;
            const selected = document.querySelectorAll('.brand-check:checked').length;
            document.getElementById('applyWatermarksBtn').disabled = !(selected > 0 && selected <= 10);
        });
        
        // Apply watermarks (Canvas-based with adaptive opacity 10-20%)
        document.getElementById('applyWatermarksBtn').addEventListener('click', async () => {
            const selected = Array.from(document.querySelectorAll('.brand-check:checked'));
            if (!selectedVideoFile || !selected.length) return;
            
            const statusDiv = document.getElementById('watermarkStatus');
            statusDiv.innerHTML = '<div class="status processing">‚è≥ Processing watermarks...</div>';
            document.getElementById('applyWatermarksBtn').disabled = true;
            
            const results = [];
            
            for (let i = 0; i < selected.length; i++) {
                const brandName = selected[i].value;
                const watermarkFile = selected[i].getAttribute('data-file');
                
                try {
                    statusDiv.innerHTML = `<div class="status processing">‚è≥ Processing ${i+1}/${selected.length}: ${brandName}...</div>`;
                    
                    const watermarkedBlob = await applyWatermarkToVideo(selectedVideoFile, watermarkFile, brandName);
                    const url = URL.createObjectURL(watermarkedBlob);
                    const filename = `${brandName}_${selectedVideoFile.name.replace(/\.[^/.]+$/, '')}.mp4`;
                    
                    results.push({ brandName, url, filename, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                    // Save to history
                    saveHistoryEntry({ type: 'watermark', name: filename, url, size_mb: (watermarkedBlob.size/(1024*1024)).toFixed(2) });
                    
                } catch (err) {
                    results.push({ brandName, error: err.message });
                }
            }
            
            // Show results
            const successCount = results.filter(r => !r.error).length;
            const items = results.map(r => {
                if (r.error) {
                    return `<div class="watermark-result" style="border-left-color:#ff5555;">‚úó ${r.brandName}: ${r.error}</div>`;
                }
                return `<div class="watermark-result">‚úì <strong>${r.brandName}</strong><br><a href="${r.url}" download="${r.filename}" class="download-link">üì• ${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
            }).join('');
            
            statusDiv.innerHTML = `<div class="status completed">‚úì Generated ${successCount}/${results.length} watermarked videos</div>${items}`;
            
            // Auto-download if enabled
            if (autoDownloadEnabled) {
                results.filter(r => !r.error).forEach(r => {
                    const a = document.createElement('a');
                    a.href = r.url;
                    a.download = r.filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                });
            }
            
            document.getElementById('applyWatermarksBtn').disabled = false;
        });
        
        // Canvas-based watermark application with adaptive opacity (10-20%)
        async function applyWatermarkToVideo(videoFile, watermarkFileName, brandName) {
            return new Promise(async (resolve, reject) => {
                try {
                    // Mobile/browser detection and capability check
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    console.log(`[WATERMARK] Device: ${isMobile ? 'Mobile' : 'Desktop'}, Browser: ${navigator.userAgent.substring(0, 50)}...`);
                    
                    // Check MediaRecorder support
                    if (!window.MediaRecorder) {
                        throw new Error('‚ùå MediaRecorder not supported. Try Chrome/Firefox/Edge.');
                    }
                    
                    // Check Canvas.captureStream support
                    const testCanvas = document.createElement('canvas');
                    if (!testCanvas.captureStream && !testCanvas.mozCaptureStream) {
                        throw new Error('‚ùå Canvas.captureStream() not supported on this browser.');
                    }
                    console.log('[WATERMARK] ‚úì MediaRecorder and captureStream supported');
                    
                    // Load video
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(videoFile);
                    video.muted = true;
                    video.playsInline = true;
                    
                    await new Promise((res, rej) => {
                        video.onloadedmetadata = res;
                        video.onerror = rej;
                    });
                    
                    // Load watermark
                    const watermark = new Image();
                    watermark.src = `/portal/static/watermarks/${watermarkFileName}`;
                    await new Promise((res, rej) => {
                        watermark.onload = () => {
                            console.log(`[WATERMARK] Image loaded: ${watermarkFileName}, Size: ${watermark.width}x${watermark.height}`);
                            res();
                        };
                        watermark.onerror = (err) => {
                            console.error(`[WATERMARK] Failed to load image: ${watermarkFileName}`, err);
                            rej(new Error(`Failed to load watermark image: ${watermarkFileName}`));
                        };
                    });
                    
                    // Force 9:16 aspect ratio
                    const targetWidth = 1080;
                    const targetHeight = 1920;
                    
                    // Canvas setup
                    const canvas = document.createElement('canvas');
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate video brightness for adaptive opacity
                    video.currentTime = video.duration / 2; // Sample middle frame
                    await new Promise(res => { video.onseeked = res; });
                    
                    ctx.drawImage(video, 0, 0, targetWidth, targetHeight);
                    const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
                    let brightness = 0;
                    for (let i = 0; i < imageData.data.length; i += 4) {
                        brightness += (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                    }
                    brightness /= (imageData.data.length / 4);
                    
                    // Adaptive opacity: 15% (bright) to 25% (dark) - subtle but visible
                    const opacity = 0.15 + (0.10 * (1 - brightness / 255));
                    
                    // Watermark positioning - FULL SCREEN COVERAGE (edge to edge)
                    // Scale watermark to fill entire video frame while maintaining aspect ratio
                    const watermarkScale = Math.max(
                        targetWidth / watermark.width,   // Fill width
                        targetHeight / watermark.height  // Fill height
                    );
                    const watermarkWidth = watermark.width * watermarkScale;
                    const watermarkHeight = watermark.height * watermarkScale;
                    // Center the watermark (it will overflow edges if aspect doesn't match)
                    const watermarkX = (targetWidth - watermarkWidth) / 2;
                    const watermarkY = (targetHeight - watermarkHeight) / 2;
                    
                    // Debug logging
                    console.log(`[WATERMARK] Brand: ${brandName}, Brightness: ${brightness.toFixed(0)}, Opacity: ${(opacity*100).toFixed(0)}%`);
                    console.log(`[WATERMARK] Watermark position: X=${watermarkX.toFixed(0)}, Y=${watermarkY.toFixed(0)}, W=${watermarkWidth.toFixed(0)}, H=${watermarkHeight.toFixed(0)}`);
                    console.log(`[WATERMARK] Video duration: ${video.duration.toFixed(2)}s, Size: ${video.videoWidth}x${video.videoHeight}`);
                    
                    // Encode using MediaRecorder
                    const stream = canvas.captureStream ? canvas.captureStream(30) : canvas.mozCaptureStream(30);
                    console.log(`[WATERMARK] Canvas stream created: ${stream.getVideoTracks().length} video tracks`);
                    
                    // Try to add audio (may fail on some browsers, especially mobile)
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const audioSource = audioContext.createMediaElementSource(video);
                        const dest = audioContext.createMediaStreamDestination();
                        audioSource.connect(dest);
                        const audioTrack = dest.stream.getAudioTracks()[0];
                        if (audioTrack) {
                            stream.addTrack(audioTrack);
                            console.log('[WATERMARK] Audio track added');
                        } else {
                            console.warn('[WATERMARK] No audio track available');
                        }
                    } catch (audioErr) {
                        console.warn('[WATERMARK] Audio processing failed, continuing without audio:', audioErr.message);
                    }
                    
                    const chunks = [];
                    // Try different codecs for mobile compatibility
                    let recorderOptions;
                    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                        recorderOptions = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 5000000 };
                    } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                        recorderOptions = { mimeType: 'video/webm;codecs=vp8', videoBitsPerSecond: 5000000 };
                    } else if (MediaRecorder.isTypeSupported('video/webm')) {
                        recorderOptions = { mimeType: 'video/webm', videoBitsPerSecond: 5000000 };
                    } else {
                        recorderOptions = { videoBitsPerSecond: 5000000 };
                    }
                    
                    const recorder = new MediaRecorder(stream, recorderOptions);
                    console.log('[WATERMARK] MediaRecorder created with:', recorder.mimeType);
                    
                    recorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
                    recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/mp4' });
                        resolve(blob);
                    };
                    
                    recorder.start();
                    video.currentTime = 0;
                    video.play();
                    
                    let frameCount = 0;
                    // Render loop
                    function render() {
                        if (video.paused || video.ended) {
                            console.log(`[WATERMARK] Rendering complete. Total frames: ${frameCount}`);
                            recorder.stop();
                            video.pause();
                            return;
                        }
                        
                        frameCount++;
                        if (frameCount === 1 || frameCount % 30 === 0) {
                            console.log(`[WATERMARK] Frame ${frameCount}, Time: ${video.currentTime.toFixed(2)}s`);
                        }
                        
                        // Draw video frame (cropped/scaled to 9:16)
                        const srcAspect = video.videoWidth / video.videoHeight;
                        const targetAspect = targetWidth / targetHeight;
                        let sx = 0, sy = 0, sw = video.videoWidth, sh = video.videoHeight;
                        
                        if (srcAspect > targetAspect) {
                            // Video wider: crop width
                            sw = video.videoHeight * targetAspect;
                            sx = (video.videoWidth - sw) / 2;
                        } else {
                            // Video taller: crop height
                            sh = video.videoWidth / targetAspect;
                            sy = (video.videoHeight - sh) / 2;
                        }
                        
                        ctx.drawImage(video, sx, sy, sw, sh, 0, 0, targetWidth, targetHeight);
                        
                        // Draw watermark with adaptive opacity
                        ctx.globalAlpha = opacity;
                        ctx.drawImage(watermark, watermarkX, watermarkY, watermarkWidth, watermarkHeight);
                        ctx.globalAlpha = 1.0;
                        
                        requestAnimationFrame(render);
                    }
                    render();
                    
                } catch (err) {
                    reject(err);
                }
            });
        }
        // ========== END PHASE B ==========
        
        // File upload
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const uploadZone = document.getElementById('uploadZone');
            const uploadText = document.getElementById('uploadText');
            
            uploadText.innerHTML = '<p>‚è≥ Uploading...</p>';
            uploadZone.classList.add('active');
            
            const formData = new FormData();
            formData.append('video', file);
            
            try {
                const response = await fetch('/api/videos/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    uploadedFilename = result.filename;
                    uploadText.innerHTML = `<p style="color: #00ff00;">‚úì ${file.name}</p><p style="font-size: 12px; color: #888; margin-top: 5px;">Ready to process</p>`;
                    document.getElementById('processBtn').disabled = false;
                } else {
                    throw new Error(result.error);
                }
            } catch (err) {
                uploadText.innerHTML = `<p style="color: #ff5555;">‚úó Upload failed: ${err.message}</p>`;
                uploadZone.classList.remove('active');
            }
        });
        
        // Helpers (fetch batch + paste/drag + reset)
        async function fetchBatchUrls(targetUrls) {
            const response = await fetch('/api/videos/fetch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ urls: targetUrls })
            });
            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Server error (${response.status}): ${text}`);
            }
            return await response.json();
        }
        function autoDownloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'video.mp4';
            document.body.appendChild(a);
            a.click();
            a.remove();
        }
        (function(){
            const linksInput = document.getElementById('linksInput');
            const fetchStatus = document.getElementById('fetchStatus');
            const resetBtn = document.getElementById('resetLinksBtn');
            if (resetBtn) {
                resetBtn.addEventListener('click', ()=>{
                    if (linksInput) linksInput.value = '';
                    if (fetchStatus) fetchStatus.innerHTML = '';
                });
            }
            if (linksInput) {
                // Paste-to-start
                linksInput.addEventListener('paste', async (e) => {
                    const text = (e.clipboardData && e.clipboardData.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    e.preventDefault();
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download="${r.filename}">${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        } finally {
                            linksInput.value = '';
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs pasted. Tap \"Download All Links\".</div>`;
                    }
                });
                // Drag & drop URLs
                linksInput.addEventListener('dragover', (e)=>{ e.preventDefault(); linksInput.style.borderColor = '#00ff00'; });
                linksInput.addEventListener('dragleave', ()=>{ linksInput.style.borderColor = '#333'; });
                linksInput.addEventListener('drop', async (e)=>{
                    e.preventDefault(); linksInput.style.borderColor = '#333';
                    const text = (e.dataTransfer && e.dataTransfer.getData('text')) || '';
                    const urls = extractURLs(text).slice(0,5);
                    if (!urls.length) return;
                    if (urls.length === 1) {
                        fetchStatus.innerHTML = '<div class="status processing">‚è≥ Downloading 1 video...</div>';
                        try {
                            const result = await fetchBatchUrls(urls);
                            const r = result.results && result.results[0];
                            if (result.success && r && r.success) {
                                saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                                fetchStatus.innerHTML = `<div class="status completed">‚úì Downloaded <a href="${r.download_url}" class="download-link" download="${r.filename}">${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></div>`;
                                if (autoDownloadEnabled) autoDownloadFile(r.download_url, r.filename);
                                renderHistory();
                            } else {
                                fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${r && r.error ? r.error : 'Download failed'}</div>`;
                            }
                        } catch (err) {
                            fetchStatus.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                        }
                    } else {
                        linksInput.value = urls.join('\n');
                        fetchStatus.innerHTML = `<div class=\"status queued\">üìã ${urls.length} URLs dropped. Tap \"Download All Links\".</div>`;
                    }
                });
            }
        })();

        // Bulk link fetcher
        document.getElementById('fetchLinksBtn').addEventListener('click', async () => {
            const raw = (document.getElementById('linksInput').value || '').trim();
            if (!raw) {
                alert('Please paste at least one video URL');
                return;
            }
            
            const urls = raw.split('\n').map(s => s.trim()).filter(Boolean).slice(0, 5);
            const fetchStatus = document.getElementById('fetchStatus');
            
            fetchStatus.innerHTML = `<div class="status processing">‚è≥ Downloading ${urls.length} video${urls.length > 1 ? 's' : ''}...</div>`;
            document.getElementById('fetchLinksBtn').disabled = true;
            
            async function fetchBatch(targetUrls) {
                const response = await fetch('/api/videos/fetch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ urls: targetUrls })
                });
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Server error (${response.status}): ${text}`);
                }
                return await response.json();
            }
            
            try {
                let result = await fetchBatch(urls);
                if (!result.success) throw new Error(result.error || 'Fetch failed');
                let finalResults = result.results;
                
                // Auto-retry for failures (once)
                const failed = finalResults.filter(r => !r.success).map(r => r.url);
                if (failed.length) {
                    try {
                        const retry = await fetchBatch(failed);
                        if (retry.success) {
                            // Merge: replace failures with retry successes
                            finalResults = finalResults.map(r => r.success ? r : (retry.results.find(rr => rr.url === r.url) || r));
                        }
                    } catch (e) {
                        // ignore retry errors
                    }
                }
                
                const items = finalResults.map(r => {
                    if (r.success) {
                        // Save to history
                        saveHistoryEntry({ type: 'link', name: r.filename, url: r.download_url, size_mb: r.size_mb });
                        return `<li style="margin-bottom:8px;">‚úì <a href="${r.download_url}" class="download-link" download="${r.filename}" style="color:#00ff00;">üì• ${r.filename}</a> <span style="color:#666;">(${r.size_mb}MB)</span> <button class="share-btn" data-url="${r.download_url}" data-filename="${r.filename}" style="margin-left:8px;">ü§ù Share</button></li>`;
                    }
                    return `<li style="margin-bottom:8px; color:#ff5555;">‚úó ${r.url.substring(0, 50)}... ‚Äî ${r.error}</li>`;
                }).join('');
                
                fetchStatus.innerHTML = `
                    <div class="status completed">
                        ‚úì Downloaded ${finalResults.filter(r=>r.success).length}/${finalResults.length} videos:<br>
                        <ul style="margin-top:10px; text-align:left; list-style:none; padding:0;">${items}</ul>
                        <p style="margin-top:12px; font-size:12px; color:#888;">üì± Tap each link to save to your phone</p>
                        <button id="copyAllLinksBtn" style="margin-top:10px; width:100%; background:#0066ff;">üìã Copy All Download Links</button>
                    </div>
                `;
                
                // Auto-download
                if (autoDownloadEnabled) {
                    finalResults.filter(r=>r.success).forEach(r => {
                        const a = document.createElement('a');
                        a.href = r.download_url;
                        a.download = r.filename;
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                    });
                }
                
                document.getElementById('linksInput').value = '';
                loadRecentJobs();
                renderHistory();
                
            } catch (err) {
                console.error('Fetch error:', err);
                fetchStatus.innerHTML = `<div class="status failed">‚úó Error: ${err.message}</div>`;
            } finally {
                document.getElementById('fetchLinksBtn').disabled = false;
            }
        });
        
        // Process video
        document.getElementById('processBtn').addEventListener('click', async () => {
            if (!uploadedFilename) return;
            
            // Clear any existing status polling
            if (statusPollInterval) {
                clearInterval(statusPollInterval);
                statusPollInterval = null;
            }
            
            const template = document.getElementById('templateSelect').value;
            const aspectRatio = document.getElementById('aspectRatioSelect').value;
            const statusDiv = document.getElementById('statusMessage');
            
            statusDiv.innerHTML = '<div class="status processing">‚è≥ Processing video...</div>';
            document.getElementById('processBtn').disabled = true;
            
            async function tryProcess(retries = 2) {
                try {
                    const response = await fetch('/api/videos/process', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filename: uploadedFilename,
                            template: template,
                            aspect_ratio: aspectRatio
                        })
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Server error (${response.status}): ${errorText}`);
                    }
                    const text = await response.text();
                    if (!text || text.trim() === '') throw new Error('Backend returned empty response');
                    const result = JSON.parse(text);
                    if (!result.success) throw new Error(result.error || 'Processing failed');
                    activeJobId = result.job_id;
                    statusDiv.innerHTML = `<div class=\"status processing\">Processing... Job ID: ${result.job_id}</div>`;
                    pollJobStatus(result.job_id);
                } catch (err) {
                    if (retries > 0) {
                        statusDiv.innerHTML = `<div class=\"status queued\">Retrying... (${retries})</div>`;
                        await new Promise(res => setTimeout(res, 1000));
                        return tryProcess(retries - 1);
                    }
                    console.error('Process error:', err);
                    statusDiv.innerHTML = `<div class=\"status failed\">‚úó Error: ${err.message}</div>`;
                    document.getElementById('processBtn').disabled = false;
                }
            }
            
            tryProcess();
        });
        
        // Poll job status
        function pollJobStatus(jobId) {
            // Clear any existing interval
            if (statusPollInterval) {
                clearInterval(statusPollInterval);
            }
            
            statusPollInterval = setInterval(async () => {
                // Only poll if this is still the active job
                if (activeJobId !== jobId) {
                    clearInterval(statusPollInterval);
                    return;
                }
                
                try {
                    const response = await fetch(`/api/videos/status/${jobId}`);
                    const job = await response.json();
                    
                    const statusDiv = document.getElementById('statusMessage');
                    
                    if (job.status === 'completed') {
                        clearInterval(statusPollInterval);
                        statusPollInterval = null;
                        statusDiv.innerHTML = `
                            <div class=\"status completed\">\n                                ‚úì Processing complete!<br>\n                                <a href=\"${job.download_url}\" class=\"download-link\" download=\"${job.output_file}\">üì• Download ${job.output_file}</a> <button class=\"share-btn\" data-url=\"${job.download_url}\" data-filename=\"${job.output_file}\" style=\"margin-left:10px;\">ü§ù Share</button>\n                            </div>
                        `;
                        loadRecentJobs();
                        // Save history
                        saveHistoryEntry({ type: 'process', name: job.output_file, url: job.download_url });
                        // Auto-download
                        if (autoDownloadEnabled && job.download_url) {
                            const a = document.createElement('a');
                            a.href = job.download_url;
                            a.download = job.output_file || 'video.mp4';
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                        }
                        renderHistory();
                        resetUpload();
                    } else if (job.status === 'failed') {
                        clearInterval(statusPollInterval);
                        statusPollInterval = null;
                        statusDiv.innerHTML = `<div class=\"status failed\">‚úó Processing failed: ${job.error || 'Unknown error'}</div>`;
                        resetUpload();
                    } else {
                        // Still processing - update status message
                        statusDiv.innerHTML = `<div class=\"status processing\">‚è≥ Processing... Job ID: ${jobId}</div>`;
                    }
                } catch (err) {
                    console.error('Status poll error:', err);
                    clearInterval(statusPollInterval);
                    statusPollInterval = null;
                }
            }, 2000);
        }
        
        // Reset upload
        function resetUpload() {
            uploadedFilename = null;
            activeJobId = null;
            document.getElementById('processBtn').disabled = false;
            document.getElementById('uploadText').innerHTML = `
                <p style="font-size: 18px; margin-bottom: 10px;">üìÅ Click or drag video here</p>
                <p style="color: #888; font-size: 14px;">Supported: MP4, MOV, AVI (max 500MB)</p>
            `;
            document.getElementById('uploadZone').classList.remove('active');
            document.getElementById('fileInput').value = '';
        }
        
        // Load recent jobs
        function loadRecentJobs() {
            fetch('/api/videos/recent?limit=10')
                .then(r => r.json())
                .then(data => {
                    const container = document.getElementById('recentJobs');
                    if (data.jobs.length === 0) {
                        container.innerHTML = '<p style="color: #666;">No jobs yet</p>';
                        return;
                    }
                    
                    container.innerHTML = data.jobs.map(job => `
                        <div class="job-item ${job.status}">
                            <strong>${job.template}</strong> 
                            <span class="status ${job.status}" style="display: inline-block; padding: 2px 8px; font-size: 11px; margin-left: 10px;">${job.status}</span>
                            <div class="job-meta">
                                ${job.aspect_ratio} ‚Ä¢ ${new Date(job.created_at).toLocaleString()}
                                ${job.status === 'completed' ? `<br><a href="/api/videos/download/${job.output_path}" class="download-link">Download</a>` : ''}
                            </div>
                        </div>
                    `).join('');
                });
        }
        
        // Load system logs
        function loadSystemLogs() {
            fetch('/api/system/logs?limit=20')
                .then(r => r.json())
                .then(data => {
                    const container = document.getElementById('systemLogs');
                    if (data.logs.length === 0) {
                        container.innerHTML = '<p style="color: #666;">No logs yet</p>';
                        return;
                    }
                    
                    container.innerHTML = data.logs.map(log => `
                        <div class="log-entry ${log.level}">
                            <span style="color: #666;">[${new Date(log.timestamp).toLocaleTimeString()}]</span>
                            ${log.message}
                        </div>
                    `).join('');
                });
        }
        
        // Auto-refresh
        loadRecentJobs();
        loadSystemLogs();
        setInterval(loadRecentJobs, 5000);
        setInterval(loadSystemLogs, 10000);
    </script>
</body>
</html>
